<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zipee&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ziperlee.github.io/zipee.github.io/"/>
  <updated>2020-01-14T14:34:13.000Z</updated>
  <id>https://ziperlee.github.io/zipee.github.io/</id>
  
  <author>
    <name>Zipee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shell编码整理</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2020/01/13/shell%E7%BC%96%E7%A0%81%E6%95%B4%E7%90%86/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2020/01/13/shell编码整理/</id>
    <published>2020-01-13T13:54:44.000Z</published>
    <updated>2020-01-14T14:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>从开始接触linux，或多或少会使用到shell，这篇文章用来整理下用过的shell语法，和比较常见的套路。</p></div><a id="more"></a><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><ul><li><p>用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if test  -e startup.sh ;then </span><br><span class="line">等价于</span><br><span class="line">if [[ -e startup.sh ]];then</span><br></pre></td></tr></table></figure></li><li><p>注意：可以使用[[]]就不要使用[]，[[]]兼容在命令中使用&amp;&amp;、||、&lt;和&gt; 等操作符</p></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p>定义数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules=(bond-web bifrost model-engine gaeaproxy)</span><br></pre></td></tr></table></figure></li><li><p>获取数组所有元素，@可被*替换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;modules[@]&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for module in "$&#123;modules[@]&#125;"; do</span><br><span class="line">echo $module</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>读取数组指定元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;modules[index]&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@可被*替换|$&#123;#my_array[@]&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>全局变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 全局变量的作用域是当前的进程，而不是前端的shell脚本文件</span><br><span class="line">a=1</span><br></pre></td></tr></table></figure></li><li><p>局部变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local a=1</span><br></pre></td></tr></table></figure></li><li><p>环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export a=1</span><br><span class="line">作用域为当前shell进程和其子进程</span><br></pre></td></tr></table></figure></li><li><p>特殊变量</p></li></ul><table><thead><tr><th style="text-align:center">示例</th><th style="text-align:left">变量含义</th></tr></thead><tbody><tr><td style="text-align:center">$@</td><td style="text-align:left">所有入参，可以通过set设置 set 11 22 33 44</td></tr><tr><td style="text-align:center">$#</td><td style="text-align:left">参数个数</td></tr><tr><td style="text-align:center">$?</td><td style="text-align:left">上个命令的退出状态</td><td>函数的返回值</td></tr><tr><td style="text-align:center">$$</td><td style="text-align:left">当前shell进程的ID</td></tr><tr><td style="text-align:center">$!</td><td style="text-align:left">Shell最后运行的后台Process的PID</td></tr><tr><td style="text-align:center">total=$#｜action=${!total}</td><td style="text-align:left">获取最后一个参数，也可通过eval action=\$$#</td></tr></tbody></table><p>｜` `｜指令定义，相较于’’，<code></code>会预执行，在指令嵌套时经常用到｜<br>｜echo $aa | echo ${aa}｜读取变量｜<br>｜$((2+3)) ｜进行整数运算｜</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><ul><li>该命令对变量进行两次扫描<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=`echo hello`</span><br><span class="line">b='echo $a' </span><br><span class="line">等价于</span><br><span class="line">a='echo hello'</span><br><span class="line">b=eval 'echo $a'</span><br></pre></td></tr></table></figure></li></ul><h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><table><thead><tr><th style="text-align:center">示例</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">‘ ‘ 单引号</td><td style="text-align:left">剥夺所有字符的特殊含义，如 n=3；echo ‘$n’ -&gt; $n</td></tr><tr><td style="text-align:center">“ “ 双引号</td><td style="text-align:left">引号内可参数替换，$和反引号 <code></code></td></tr><tr><td style="text-align:center"><code></code>反引号</td><td style="text-align:left">用命令替换，即先执行<code></code>内命令，将输出结果暂存，在适当的地方输出</td></tr></tbody></table><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ehco 'haha' &gt; /tmp/tmp.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="常见的服务启动脚本"><a href="#常见的服务启动脚本" class="headerlink" title="常见的服务启动脚本"></a>常见的服务启动脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">eval action=\$$#</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    case "$module" in</span><br><span class="line">        module1)</span><br><span class="line">            start_cmd="cmd1"</span><br><span class="line">            ;;</span><br><span class="line">        module2)</span><br><span class="line">            start_cmd="cmd2"</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            echo "usage: $module &#123;module1|module2&#125;"</span><br><span class="line">            exit -1</span><br><span class="line">    esac</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">all() &#123;</span><br><span class="line">  for module in "$&#123;modules[@]&#125;"; do</span><br><span class="line">      main</span><br><span class="line">      echo</span><br><span class="line">        echo "[INFO] $module:"</span><br><span class="line">            echo "[INFO] processing: $&#123;module&#125; $&#123;action&#125;"</span><br><span class="line">            echo "=================="</span><br><span class="line">            action</span><br><span class="line">            echo "--------------"</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">action() &#123;</span><br><span class="line">case "$action" in</span><br><span class="line">start)</span><br><span class="line">start</span><br><span class="line">status</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">stop</span><br><span class="line">;;</span><br><span class="line">status)</span><br><span class="line">status</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">stop</span><br><span class="line">start</span><br><span class="line">status</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo "usage: $action &#123;start|stop|status|restart&#125;"</span><br><span class="line">exit -1</span><br><span class="line">esac</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usage() &#123;</span><br><span class="line">    echo "usage: $0 &#123;all|[module1, ...]&#125; &#123;start|stop|status|restart&#125;"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiple() &#123;</span><br><span class="line">    total=$#</span><br><span class="line">    action=$&#123;!total&#125;</span><br><span class="line">    for (( i=1; i&lt;total; i++)); do</span><br><span class="line">        module=$&#123;!i//\//&#125;</span><br><span class="line">        main</span><br><span class="line">     echo "[INFO] $module:$&#123;start_cmd&#125;"</span><br><span class="line">        echo "[INFO] processing: $&#123;module&#125; $&#123;action&#125;"</span><br><span class="line">        echo "=================="</span><br><span class="line">        action</span><br><span class="line">        echo "--------------"</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getpid() &#123;</span><br><span class="line">    if [ ! -d "pids" ]; then</span><br><span class="line">        mkdir pids</span><br><span class="line">    fi</span><br><span class="line">    if [ ! -f "pids/$&#123;module&#125;_pid" ];then</span><br><span class="line">        echo "" &gt; pids/$&#123;module&#125;_pid</span><br><span class="line">    fi</span><br><span class="line">    module_pid=`cat pids/$&#123;module&#125;_pid`</span><br><span class="line"></span><br><span class="line">    pid=`ps aux | grep $&#123;module_pid&#125; | grep -v grep | grep -v $0 | awk '&#123;print $2&#125;'`</span><br><span class="line"></span><br><span class="line">    if [[ -n $&#123;pid&#125; ]]; then</span><br><span class="line">        return 0</span><br><span class="line">    else</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status() &#123;</span><br><span class="line">    getpid</span><br><span class="line">    if [[ -n $&#123;pid&#125; ]]; then</span><br><span class="line">        echo "status:</span><br><span class="line">        `ps aux | grep $&#123;pid&#125; | grep -v grep`"</span><br><span class="line">        return 0</span><br><span class="line">    else</span><br><span class="line">        echo "service not running"</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">    getpid</span><br><span class="line">    if [[ $? -eq 1 ]]; then</span><br><span class="line">        eval $start_cmd</span><br><span class="line">        echo $!&gt;pids/$&#123;module&#125;_pid</span><br><span class="line">        getpid</span><br><span class="line">        if [[ $? -eq 0 ]]; then</span><br><span class="line">            echo "service start sucessfully. pid: $&#123;pid&#125;"</span><br><span class="line">        else</span><br><span class="line">            echo "service start failed"</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        echo "service already started. pid: $&#123;pid&#125;"</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    getpid</span><br><span class="line">    if [[ -n $&#123;pid&#125; ]]; then</span><br><span class="line">        echo "killing:</span><br><span class="line">        `ps aux | grep $&#123;pid&#125; | grep -v grep`"</span><br><span class="line">        kill -9 $&#123;pid&#125; &amp;&amp; sleep 0.01</span><br><span class="line">    getpid</span><br><span class="line">        if [[ $? -eq 1 ]]; then</span><br><span class="line">            echo "killed"</span><br><span class="line">        else</span><br><span class="line">            echo "kill error"</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        echo "service not running"</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case "$1" in</span><br><span class="line">    all)</span><br><span class="line">        all $@</span><br><span class="line">        ;;</span><br><span class="line">    usage)</span><br><span class="line">        usage</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        multiple $@</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><ul><li>注意服务启动间隔如果不加<code>sleep 0.01</code>，可能会导致获取服务状态异常，即杀掉服务需要一定的信号处理时间</li></ul><h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h2><ul><li>将启动指令配置进/etc/rc.d/rc.local</li><li>注意，任何一个脚本执行失败，即exit非0，将导致该shell session内的所有启动服务失败，而如何配置在rc.local中的指令exit非0，将导致整个系统初始化失败</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;从开始接触linux，或多或少会使用到shell，这篇文章用来整理下用过的shell语法，和比较常见的套路。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="shell" scheme="https://ziperlee.github.io/zipee.github.io/categories/shell/"/>
    
    
      <category term="部署" scheme="https://ziperlee.github.io/zipee.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="shell" scheme="https://ziperlee.github.io/zipee.github.io/tags/shell/"/>
    
      <category term="运维" scheme="https://ziperlee.github.io/zipee.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>兼职运维之ulimit</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/12/27/%E5%85%BC%E8%81%8C%E8%BF%90%E7%BB%B4%E4%B9%8Bulimit-u/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/12/27/兼职运维之ulimit-u/</id>
    <published>2019-12-27T13:09:45.000Z</published>
    <updated>2020-01-14T13:15:04.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>今天部署生产环境遇到了坑，本文聊聊这个坑的上下文。</p></div><a id="more"></a><h2 id="现象-amp-定位"><a href="#现象-amp-定位" class="headerlink" title="现象&amp;定位"></a>现象&amp;定位</h2><ul><li>部署完成后，收到测试人员反馈业务运行异常</li><li><p>排查后，定位为livy向spark提交任务时执行失败<br>livy日志如下：<br><img src="https://i.loli.net/2019/12/27/tVroEwZsClS9b54.jpg" alt="spark异常.jpg"></p></li><li><p>初看有点懵，将关键字<code>spark</code>和<code>OpenBLAS blas_thread_init</code>提交google，结果大多匹配python运行时相关异常，<br><img src="https://i.loli.net/2019/12/27/4rdolfctzh18ZCE.jpg" alt="spark异常google.jpg"></p></li><li><p>仔细看不难发现<code>RLIMIT_NPROC 4096 current, 514476 max</code></p></li><li>由此自然联想到<code>ulimit -u</code>，一查发现果然只有4096</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>解决方案也简单，设置系统最大允许进程数</li></ul><p><strong>永久生效：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/security/limits.d/90-nproc.conf</span><br><span class="line">或</span><br><span class="line">/etc/security/limits.conf</span><br><span class="line">在末行加入</span><br><span class="line">* hard nproc 1000000</span><br><span class="line">* soft nproc 1000000</span><br></pre></td></tr></table></figure><p><strong>当前session生效：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -u 1000000</span><br></pre></td></tr></table></figure><ul><li>重新测试，问题果然修复</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>问题事后看并不复杂，但前前后后还是花了不少时间，其实之前ulimit也不是没学习过，但真正出现异常时，往往没有看透问题的本质</li><li>该生产环境主机时刚部署的，毕竟兼职运维，像ulimit此类系统资源的设置没有统一的整体设置过，吃一堑长一智，兼职运维的路上且走且学吧</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;今天部署生产环境遇到了坑，本文聊聊这个坑的上下文。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="linux" scheme="https://ziperlee.github.io/zipee.github.io/categories/linux/"/>
    
    
      <category term="兼职运维" scheme="https://ziperlee.github.io/zipee.github.io/tags/%E5%85%BC%E8%81%8C%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>fabric使用总结</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/12/23/fabric%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/12/23/fabric使用总结/</id>
    <published>2019-12-23T13:16:44.000Z</published>
    <updated>2019-12-28T09:06:21.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>fabric可谓部署神器，在小规模集群环境部署方面简直就是<code>屠龙刀</code>的存在</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>fabric目前存在两个版本，分别对应python2和python3</li><li>本文主要介绍fabric两个版本的常用方法</li></ul><h2 id="fabric（python2）"><a href="#fabric（python2）" class="headerlink" title="fabric（python2）"></a>fabric（python2）</h2><h3 id="安装（python2环境）"><a href="#安装（python2环境）" class="headerlink" title="安装（python2环境）"></a>安装（python2环境）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fabric</span><br></pre></td></tr></table></figure><h3 id="若要实现ssh跳转，需另外安装fexpect"><a href="#若要实现ssh跳转，需另外安装fexpect" class="headerlink" title="若要实现ssh跳转，需另外安装fexpect"></a>若要实现ssh跳转，需另外安装fexpect</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fexpect</span><br></pre></td></tr></table></figure><h3 id="fabric2的API对应部署的对象定义比较明了"><a href="#fabric2的API对应部署的对象定义比较明了" class="headerlink" title="fabric2的API对应部署的对象定义比较明了"></a>fabric2的API对应部署的对象定义比较明了</h3><ul><li>env（定义部署主机的ip，密码，节点属性，全局变量等）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dev</span><span class="params">()</span>:</span></span><br><span class="line">    env.roledefs = &#123;</span><br><span class="line">        <span class="string">"manager"</span>: [<span class="string">"user@x.x.x.x:22"</span>],</span><br><span class="line">        <span class="string">"worker"</span>: [<span class="string">"user@x.x.x.x:22"</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    env.passwords = &#123;<span class="string">"user@x.x.x.x:22"</span>: <span class="string">"123456"</span>, <span class="string">"user@x.x.x.x:22"</span>: <span class="string">"123456"</span>&#125;</span><br><span class="line">    <span class="keyword">global</span> ENV_PARAM</span><br><span class="line">    ENV_PARAM = <span class="string">"dev"</span></span><br></pre></td></tr></table></figure><ul><li>roles</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@roles("manager")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_swarm</span><span class="params">(tag, compose_file=<span class="string">"docker-compose.yml"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> cd(SRC_PATH):</span><br><span class="line">        <span class="keyword">with</span> shell_env(ENV_PARAM = ENV_PARAM, TAG=tag):</span><br><span class="line">            run(</span><br><span class="line">                <span class="string">"docker stack deploy --with-registry-auth -c deploy/swarm_deploy/&#123;&#125; &#123;&#125;"</span>.format(  <span class="comment"># noqa</span></span><br><span class="line">                    compose_file, PREFIX</span><br><span class="line">                )</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><ul><li>run</li></ul><p>执行shell指令</p><ul><li>hide, settings </li></ul><p>配合使用，隐藏输出内容等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> settings(hide(<span class="string">"warnings"</span>, <span class="string">"running"</span>, <span class="string">"stdout"</span>, <span class="string">"stderr"</span>), warn_only=<span class="keyword">True</span>):</span><br></pre></td></tr></table></figure><ul><li>cd，sudo</li></ul><p>同shell指令</p><ul><li>execute</li></ul><p>在本地任务中执行其他任务函数，提高代码复用率</p><ul><li>shell_env</li></ul><p>设置环境变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> shell_env(ASSET_CONFIG=ASSET_CONFIG, TAG=tag):</span><br><span class="line">    run(</span><br><span class="line">        <span class="string">"docker stack deploy --with-registry-auth -c deploy/swarm_deploy/&#123;&#125; &#123;&#125;"</span>.format(  <span class="comment"># noqa</span></span><br><span class="line">            compose_file, PREFIX</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><ul><li>配合fexpect使用</li></ul><p>贴了段之前用过的代码，可用于修饰任务函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">env_init</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="comment"># 代码目录</span></span><br><span class="line">    <span class="keyword">global</span> SRC_PATH</span><br><span class="line">    SRC_PATH = <span class="string">""</span></span><br><span class="line">    <span class="comment"># 私有镜像仓库</span></span><br><span class="line">    <span class="keyword">global</span> REGISTRY_HOST</span><br><span class="line">    REGISTRY_HOST = <span class="string">""</span></span><br><span class="line">    <span class="keyword">global</span> REGISTRY_USER</span><br><span class="line">    REGISTRY_USER = <span class="string">""</span></span><br><span class="line">    <span class="keyword">global</span> REGISTRY_PWD</span><br><span class="line">    REGISTRY_PWD = <span class="string">""</span></span><br><span class="line">    <span class="comment"># 项目前缀</span></span><br><span class="line">    <span class="keyword">global</span> PREFIX</span><br><span class="line">    PREFIX = <span class="string">"asset"</span></span><br><span class="line">    <span class="comment"># 主节点ip</span></span><br><span class="line">    <span class="keyword">global</span> MANAGER_IP, MANAGER_SSL, MANAGER_PWD</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_manager_ip</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> env.roledefs[<span class="string">"manager"</span>][<span class="number">0</span>][<span class="number">6</span>:<span class="number">-3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_manager_ssl</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> env.roledefs[<span class="string">"manager"</span>][<span class="number">0</span>][:<span class="number">-3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># EXPECT</span></span><br><span class="line">    <span class="keyword">global</span> PROMPTS</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> MANAGER_IP, MANAGER_SSL, MANAGER_PWD, PROMPTS</span><br><span class="line">        MANAGER_IP = _get_manager_ip()</span><br><span class="line">        MANAGER_SSL = _get_manager_ssl()</span><br><span class="line">        MANAGER_PWD = env.passwords[env.roledefs[<span class="string">"manager"</span>][<span class="number">0</span>]]</span><br><span class="line">        PROMPTS = expect(</span><br><span class="line">            <span class="string">"Are you sure you want to continue connecting (yes/no)?"</span>, <span class="string">"yes"</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><hr><h2 id="fabric（python3）"><a href="#fabric（python3）" class="headerlink" title="fabric（python3）"></a>fabric（python3）</h2><h3 id="安装（python3环境）"><a href="#安装（python3环境）" class="headerlink" title="安装（python3环境）"></a>安装（python3环境）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fabric</span><br></pre></td></tr></table></figure><h3 id="fabirc3的API相较而言显的抽象简单"><a href="#fabirc3的API相较而言显的抽象简单" class="headerlink" title="fabirc3的API相较而言显的抽象简单"></a>fabirc3的API相较而言显的抽象简单</h3><ul><li>Connection 作为连接通道抽象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接本地</span></span><br><span class="line">local_conn = Connection(<span class="string">'localhost'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程连接</span></span><br><span class="line"><span class="comment"># 没了envAPI只能自己手动定义连接环境</span></span><br><span class="line">envs = &#123;</span><br><span class="line">    <span class="string">'remote'</span>: &#123;</span><br><span class="line">        <span class="string">'host_name'</span>: <span class="string">'xx'</span>,</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">'user@x.x.x.x:22'</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">'123456'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">conn = Connection(</span><br><span class="line">    env.get(<span class="string">'host'</span>),</span><br><span class="line">    connect_kwargs=&#123;<span class="string">'password'</span>: env.get(<span class="string">'password'</span>)&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>task 定义任务</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deploy</span><span class="params">(ctx, debug=True)</span>:</span></span><br><span class="line">    mvn_package(ctx)</span><br><span class="line">    send_jar_2_remote(ctx)</span><br><span class="line">    start_server(ctx, debug=debug)</span><br></pre></td></tr></table></figure><p>通过<code>fab deploy</code>执行该任务，值得注意的是ctx这个变量必须要写<br>指定传参<code>fab start-server --jar-timestamp=20191203-1637 debug=True</code>(让人琢磨尝试了半天)</p><ul><li>其他注意点</li></ul><p>对task任务函数使用装饰器，需要注意ctx的传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span><span class="params">(start_msg=None, end_msg=None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(ctx, *args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start_msg:</span><br><span class="line">                print(start_msg)</span><br><span class="line">            start = time.time()</span><br><span class="line">            res = func(ctx, *args, **kwargs)</span><br><span class="line">            <span class="keyword">if</span> end_msg:</span><br><span class="line">                print(<span class="string">f'<span class="subst">&#123;end_msg&#125;</span>： <span class="subst">&#123;round((time.time() - start), <span class="number">2</span>)&#125;</span>s'</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p>然而遗憾的是，在自定义装饰器的修饰下，再使用命令行传参将失效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时debug的将无法被解析</span></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="meta">@timeit(end_msg='发布完成')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deploy</span><span class="params">(ctx, debug=True)</span>:</span></span><br><span class="line">    mvn_package(ctx)</span><br><span class="line">    send_jar_2_remote(ctx)</span><br><span class="line">    start_server(ctx, debug=debug)</span><br></pre></td></tr></table></figure><p>究其原因，是invoke中使用的python2的inspect.getargspec，而python3中删除了对应函数，并且six对此并未兼容，从而导致参数解析失败</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">argspec</span><span class="params">(self, body)</span>:</span></span><br><span class="line">    func = body <span class="keyword">if</span> isinstance(body, types.FunctionType) <span class="keyword">else</span> body.__call__</span><br><span class="line">    spec = inspect.getargspec(func)</span><br><span class="line">    arg_names = spec.args[:]</span><br><span class="line">    matched_args = [reversed(x) <span class="keyword">for</span> x <span class="keyword">in</span> [spec.args, spec.defaults <span class="keyword">or</span> []]]</span><br><span class="line">    spec_dict = dict(zip_longest(*matched_args, fillvalue=NO_DEFAULT))</span><br><span class="line">    <span class="comment"># Pop context argument</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        context_arg = arg_names.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">except</span> IndexError:</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> see TODO under __call__, this should be same type</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">"Tasks must have an initial Context argument!"</span>)</span><br><span class="line">    <span class="keyword">del</span> spec_dict[context_arg]</span><br><span class="line">    <span class="keyword">return</span> arg_names, spec_dict</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>综上，可以看出fabric3较fabric2而言基本是完败，使用过fabric2再迁移到fabric3是格外的别扭，由此不难理解网上对fabric3对使用教程基本上寥寥无几，即便存在大部分也只是对官网用例的简单翻译，谈不上工业级的使用</li><li>fabric3是面向程序编程而非面向human编程</li><li>无奈于python2终将被淘汰，还是对fabric3保留一些些期待吧</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;fabric可谓部署神器，在小规模集群环境部署方面简直就是&lt;code&gt;屠龙刀&lt;/code&gt;的存在&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="部署" scheme="https://ziperlee.github.io/zipee.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>hexo容器化部署</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/12/22/hexo%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/12/22/hexo容器化部署/</id>
    <published>2019-12-22T14:09:24.000Z</published>
    <updated>2019-12-28T09:06:21.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>hexo容器化部署，从此再无系统环境迁移的烦恼。</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>本文介绍从hexo windows环境改造为docker容器化运行环境。</li></ul><h2 id="改造过程"><a href="#改造过程" class="headerlink" title="改造过程"></a>改造过程</h2><p>hexo宿主机环境部署和docker的使用就不再赘述了，google大法既可。</p><ul><li>本着一切从简原则，直接搜了<a href="https://hub.docker.com/search?q=hexo&amp;type=image" target="_blank" rel="noopener">dockerhub</a>，选了个最多下载的<a href="https://hub.docker.com/r/ipple1986/hexo/dockerfile" target="_blank" rel="noopener">ipple1986/hexo</a>，发现直接拉取镜像是可以用的：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ipple1986/hexo</span><br></pre></td></tr></table></figure><ul><li>但我往往更倾向于对dockerfile重新定制，毕竟直接FROM第三方库多少会有点不透明性</li><li>于是拿着对方的dockerfile尝试重新构建镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">ENV LANG C.UTF-8</span><br><span class="line">LABEL author=ipple1986 email=ipple1986@gmail.com site=https://zhaozhiwen.net.cn</span><br><span class="line">WORKDIR /opt/hexo</span><br><span class="line">RUN yum install -y  epel-release &amp;&amp; \</span><br><span class="line">yum install -y nodejs &amp;&amp; npm config set registry https://registry.npm.taobao.org \</span><br><span class="line">&amp;&amp; npm install hexo-cli -g  &amp;&amp; hexo init ipple1986 &amp;&amp; cd ipple1986 &amp;&amp; npm install</span><br><span class="line">WORKDIR ipple1986</span><br><span class="line">EXPOSE 4000</span><br><span class="line">ENTRYPOINT [&quot;hexo&quot;,&quot;server&quot;]</span><br></pre></td></tr></table></figure><ul><li>结果hexo使用直接报错</li></ul><p><img src="https://i.loli.net/2019/12/22/4N2AI7PvGl9Ep1C.png" alt="nodejs版本过低异常.png"></p><ul><li>google分析不难看出是nodejs版本过低，通过yum指定安装node版本即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --location https://rpm.nodesource.com/setup_10.x | bash</span><br></pre></td></tr></table></figure><ul><li>于是，最终的dockerfile为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">ENV LC_ALL en_US.UTF-8</span><br><span class="line">ENV TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line">LABEL maintainer=&quot;liwei &lt;839728919@qq.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">WORKDIR /opt/hexo</span><br><span class="line">RUN curl --location https://rpm.nodesource.com/setup_10.x | bash &amp;&amp; \</span><br><span class="line">yum install -y epel-release nodejs git &amp;&amp; \</span><br><span class="line">npm config set registry https://registry.npm.taobao.org &amp;&amp; \</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">EXPOSE 4000</span><br><span class="line">CMD [&quot;hexo&quot;, &quot;server&quot;]</span><br></pre></td></tr></table></figure><ul><li>使用指令如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译镜像</span></span><br><span class="line">docker build -t blog .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run -it -v your-code-path:/opt/hexo --name blog blog:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it blog bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo部署</span></span><br><span class="line">hexo d <span class="comment"># 注意需要配置git，亦可手动输入账号密码</span></span><br></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li>hexo在其他主机上的docker容器中<code>hexo d</code>部署失败（gitpage bulid failed），已比对发现是.deploy_git没有同步更新，手动删除并<code>hexo g -d</code>，成功修复</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;hexo容器化部署，从此再无系统环境迁移的烦恼。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://ziperlee.github.io/zipee.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>flask-caching源码浅析</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/07/14/flask-caching%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/07/14/flask-caching源码浅析/</id>
    <published>2019-07-14T11:49:26.000Z</published>
    <updated>2019-12-25T14:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>flask-caching源码浅析。</p></div><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>flash-caching是一款flask开发技术栈中使用频率非常高的一款插件，起初的名称为“flask-cache”，由于原作者不再维护，后由其他人在其基础上开发维护了flask-caching。</li><li>flask-caching支持后端存储类型（本文主要围绕使用redis的源码展开）：<ul><li>simple 程序内部缓存</li><li>filesystem 系统文件缓存</li><li>redis</li><li>redissentinel</li><li>uwsgi</li><li>memcached</li><li>gaememcached</li><li>saslmemcached</li><li>spreadsaslmemcached</li></ul></li></ul><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_caching <span class="keyword">import</span> Cache</span><br><span class="line">cache = Cache()</span><br><span class="line"></span><br><span class="line">config = &#123;<span class="string">"CACHE_TYPE"</span>: <span class="string">"redis"</span>, <span class="string">"CACHE_REDIS_URL"</span>: app.config[<span class="string">"CACHE_REDIS_URL"</span>]&#125;</span><br><span class="line">    cache.init_app(app, config=config)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/cache_test/&lt;int:id&gt;')</span></span><br><span class="line"><span class="meta">@cache.cached(timeout=60 * 5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cache_test</span><span class="params">(id)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line">    got_data = request.get_json()</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;got_data&#125;</span>.<span class="subst">&#123;id&#125;</span>.<span class="subst">&#123;time.time()&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@cache.memoize(timeout=60 * 5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f_cache</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/cache_test2/&lt;int:id&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cache_test2</span><span class="params">(id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;f_cache(id)&#125;</span>"</span></span><br></pre></td></tr></table></figure><h2 id="cache-memoize源码解析"><a href="#cache-memoize源码解析" class="headerlink" title="cache memoize源码解析"></a>cache memoize源码解析</h2><h3 id="cached"><a href="#cached" class="headerlink" title="cached"></a><strong>cached</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cached</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    self,</span></span></span><br><span class="line"><span class="function"><span class="params">    timeout=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    key_prefix=<span class="string">"view/%s"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    unless=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    forced_update=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    response_filter=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    query_string=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    hash_method=hashlib.md5,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>:</span></span><br><span class="line">    <span class="string">"""..."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(f)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorated_function</span><span class="params">(*args, **kwargs)</span>:</span>...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">                rv = f(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> response_filter <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> response_filter(rv):</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        self.cache.set(</span><br><span class="line">                            cache_key,</span><br><span class="line">                            rv,</span><br><span class="line">                            timeout=decorated_function.cache_timeout,</span><br><span class="line">                        )</span><br><span class="line">                    <span class="keyword">except</span> Exception:</span><br><span class="line">                        <span class="keyword">if</span> self.app.debug:</span><br><span class="line">                            <span class="keyword">raise</span></span><br><span class="line">                        logger.exception(</span><br><span class="line">                            <span class="string">"Exception possibly due to cache backend."</span></span><br><span class="line">                        )</span><br><span class="line">            <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">make_cache_key</span><span class="params">(*args, **kwargs)</span>:</span>...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_make_cache_key_query_string</span><span class="params">()</span>:</span>...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_make_cache_key</span><span class="params">(args, kwargs, use_request)</span>:</span>...</span><br><span class="line"></span><br><span class="line">        decorated_function.uncached = f</span><br><span class="line">        decorated_function.cache_timeout = timeout</span><br><span class="line">        decorated_function.make_cache_key = make_cache_key</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decorated_function</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><ul><li>cached是针对flask视图函数的缓存，使用过程中，我们主要关注以下几个参数：<ul><li>timeout用于指定缓存失效的时间，设置0或-1则不失效</li><li>unless是一个函数，用于判断是否需要跳过缓存，可自定义实现</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_make_cache_key</span><span class="params">(args, kwargs, use_request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> callable(key_prefix):</span><br><span class="line">        cache_key = key_prefix()</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">"%s"</span> <span class="keyword">in</span> key_prefix:</span><br><span class="line">        <span class="keyword">if</span> use_request:</span><br><span class="line">            cache_key = key_prefix % request.path</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cache_key = key_prefix % url_for(f.__name__, **kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cache_key = key_prefix</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cache_key</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li>默认情况下进入逻辑”elif “%s” in key_prefix:”, 因此cached缓存只与requesturl相关，与视图函数的传参无关，<code>这里不太了解作者的实现意图，为什么不结合请求参数，且不太方便扩展或重写_make_cache_key</code>，若需要结合请求参数进行缓存，则就要对整个cached方便重写，存在大量冗余代码。具体的实现大概为通过flask.request.get_json()获取request_body，并结合业务对影响缓存的参数设置缓存。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_make_cache_key</span><span class="params">(args, kwargs, use_request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> callable(key_prefix):</span><br><span class="line">        cache_key = key_prefix()</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">"%s"</span> <span class="keyword">in</span> key_prefix:</span><br><span class="line">        <span class="keyword">if</span> use_request:</span><br><span class="line">            cache_key = key_prefix % request.path</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cache_key = key_prefix % url_for(f.__name__, **kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cache_key = key_prefix</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cache_key</span><br></pre></td></tr></table></figure><ul><li>另外值得学习的是装饰器最后一层的写法，结合了面向对象的思想，设置关键的属性到函数对象，结合后续删除等操作，非常优雅非常pythonic。</li></ul><h3 id="memoize"><a href="#memoize" class="headerlink" title="memoize"></a><strong>memoize</strong></h3><ul><li>memoize相较于cached的区别<ul><li>cache_key实现不同，memoize对key进行了加密</li><li>针对普通函数缓存结果使用</li><li>支持区分函数参数的缓存，索引cached基于参数的缓存改造，可以参考memoize的实现</li></ul></li></ul><h2 id="总结-如何写一个缓存框架"><a href="#总结-如何写一个缓存框架" class="headerlink" title="总结-如何写一个缓存框架"></a>总结-如何写一个缓存框架</h2><p>从flask-caching的实现看出，实现缓存，逻辑还是很清晰的：<code>判断是否跳过缓存，生成查询key，获取缓存数据</code>。<br>我们如果要实现缓存框架，大体需要考虑一下几方面：</p><ul><li>支持使用不同的存储实例，<strong>抽象缓存对象接口</strong>，如<code>get，has，set</code></li><li>支持区分参数缓存</li><li>支持缓存时效性</li><li>支持缓存数据加密</li><li>如果要结合业务，则最好再额外添加业务层，统一对缓存调用进行管理</li></ul><h2 id="使用缓存的注意事项（待补充）"><a href="#使用缓存的注意事项（待补充）" class="headerlink" title="使用缓存的注意事项（待补充）"></a>使用缓存的注意事项（待补充）</h2><ul><li>缓存穿透</li><li>缓存雪崩</li><li>缓存集群</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;flask-caching源码浅析。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="flask" scheme="https://ziperlee.github.io/zipee.github.io/tags/flask/"/>
    
      <category term="python" scheme="https://ziperlee.github.io/zipee.github.io/tags/python/"/>
    
      <category term="源码浅析" scheme="https://ziperlee.github.io/zipee.github.io/tags/%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法总结</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/06/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/06/16/数据结构与算法总结/</id>
    <published>2019-06-16T08:02:18.000Z</published>
    <updated>2019-06-16T08:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>总结下算法与数据结构的基础知识，虽然网络上有现成的总结，但拿来主义不是学习编程该走的捷径。</p></div><a id="more"></a><h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p><img src="https://i.loli.net/2019/06/16/5d05fac1bcc8e83459.png" alt="优劣示意图.png"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://i.loli.net/2019/06/16/5d05fac1e674389225.png" alt="数据结构复杂度.png"></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><img src="https://i.loli.net/2019/06/16/5d05fac1d4a8f86311.png" alt="排序复杂度.png"></p><h2 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h2><p><img src="https://i.loli.net/2019/06/16/5d05fac19111547738.png" alt="堆.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;总结下算法与数据结构的基础知识，虽然网络上有现成的总结，但拿来主义不是学习编程该走的捷径。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="algorithm&amp;datastructure" scheme="https://ziperlee.github.io/zipee.github.io/categories/algorithm-datastructure/"/>
    
    
      <category term="algorithm" scheme="https://ziperlee.github.io/zipee.github.io/tags/algorithm/"/>
    
      <category term="datastructure" scheme="https://ziperlee.github.io/zipee.github.io/tags/datastructure/"/>
    
  </entry>
  
  <entry>
    <title>python程序员开发规范</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/06/09/python%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/06/09/python程序员开发规范/</id>
    <published>2019-06-09T07:12:51.000Z</published>
    <updated>2019-06-09T08:49:37.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文介绍两个python开发工具（flake8，black），并结合pycharm，pre-commit进行使用。</p></div><a id="more"></a><h2 id="flake8"><a href="#flake8" class="headerlink" title="flake8"></a>flake8</h2><ul><li>基于PEP8的静态代码检查工具。有助于约束团队使用统一的代码规范。</li><li>安装 <code>pip install flake8</code></li><li>指定文件检查 <code>flake8 path/code.py</code></li><li>指定目录检查 <code>flake8 path</code></li><li>忽略指定错误 <code>flake8 --ignore E24,W504 path</code></li><li>指定配置文件 <code>flake8 --config path1/.flake8 path2 （linux下默认查找用户目录）</code></li><li>代码指定行忽略检查 <code># noqa</code></li><li><a href="https://lintlyci.github.io/Flake8Rules/" target="_blank" rel="noopener">异常快速定位</a></li></ul><p><strong>配置文件模版</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[flake8]</span><br><span class="line">ignore =</span><br><span class="line">    E203 # whitespace before &apos;:&apos;</span><br><span class="line">    E741 # ambiguous variable name &apos;l&apos;</span><br><span class="line">filename =</span><br><span class="line">exclude =</span><br><span class="line">max-line-length = 89</span><br><span class="line">max-complexity = 10  # 指定代码最高复杂度</span><br></pre></td></tr></table></figure></p><p><strong>windows下配合pycharm使用</strong>：<br><code>File-&gt;Settings-&gt;Tools-&gt;External Tools-&gt;add</code><br><img src="https://i.loli.net/2019/06/09/5cfcc0aac588786191.png" alt="pycharm.flake8.png"></p><h2 id="black"><a href="#black" class="headerlink" title="black"></a>black</h2><ul><li>flake8经常会检查出代码格式上的异常，手动修改实在烦人，这时候推荐使用这款自动格式化代码神器，从此团队code review只需要关注代码业务逻辑</li><li>基本不需要自定义配置文件（虽然支持），相较于pylint需要各种自定义设置，black的极简哲学让我想到了iphone，”产品来告诉你你真正想要的”（产品决定需求）</li><li>安装 <code>pip install black</code></li><li>black –diff path/code.py <code>输出格式化差异</code></li><li>black path/code.py <code>自动格式代码</code>（简单暴力）</li></ul><p><strong>windows下配合pycharm使用</strong>：<br><code>File-&gt;Settings-&gt;Tools-&gt;External Tools-&gt;add</code><br><img src="https://i.loli.net/2019/06/09/5cfcc0aac58b837834.png" alt="pycharm.black.png"></p><h2 id="配合使用pre-commit"><a href="#配合使用pre-commit" class="headerlink" title="配合使用pre-commit"></a>配合使用pre-commit</h2><ul><li>安装 <code>pip install pre_commit</code></li><li>创建配置文件 <code>touch .pre-commit-config.yaml</code></li><li>初始化 <code>pre-commit install</code></li><li>垃圾回收 <code>pre-commit gc</code></li></ul><p><strong>配置模版</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">repos:</span><br><span class="line">-   repo: https://github.com/ambv/black</span><br><span class="line">    rev: stable</span><br><span class="line">    hooks:</span><br><span class="line">    - id: black</span><br><span class="line">      language_version: python3.6</span><br><span class="line">-   repo: https://github.com/pre-commit/pre-commit-hooks</span><br><span class="line">    rev: v2.2.3</span><br><span class="line">    hooks:</span><br><span class="line">    - id: flake8</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文介绍两个python开发工具（flake8，black），并结合pycharm，pre-commit进行使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://ziperlee.github.io/zipee.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pycharm远程调试</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/04/27/pycharm%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/04/27/pycharm远程调试/</id>
    <published>2019-04-27T00:00:34.000Z</published>
    <updated>2019-05-04T04:05:29.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>pycharm是目前python开发者中最受欢迎的IDE，今天来介绍它的远程调试功能。<br>请注意文中介绍的所有功能仅出现在pycharm专业版版中。</p></div><a id="more"></a><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><ul><li><code>File</code>-&gt;<code>Settings</code>-&gt;<code>Project</code>-&gt;<code>Project Interpreter</code>-&gt;<code>add</code></li><li>配置mapping，本地代码与远程代码的映射，<code>此步骤是必须的</code>，方式可以通过挂载或者Tool-&gt;Configure-&gt;SFTP</li><li>Interpreter设置完后请确认<code>External Libraries</code>-&gt;<code>Remote Libraries</code>生成，若未出现，重启pycharm或许有奇迹</li></ul><h2 id="SSL-Interpreter"><a href="#SSL-Interpreter" class="headerlink" title="SSL Interpreter"></a>SSL Interpreter</h2><p><img src="https://i.loli.net/2019/05/04/5ccd05b56616c.png" alt="pycharm.ssh.png"></p><p>这里需要注意远程的运行环境必须是venv|virtualenv，若使用conda将导致无法获取<code>Remote Libraries</code>，从而无法远程debug</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul><li>开启docker守护进程的API调用</li><li>mapping需要另外挂载<br><img src="https://i.loli.net/2019/05/04/5ccd06162dfdb.png" alt="pycharm.docker.png"></li></ul><h2 id="Docker-Compose（推荐）"><a href="#Docker-Compose（推荐）" class="headerlink" title="Docker Compose（推荐）"></a>Docker Compose（推荐）</h2><ul><li>mapping挂载可以直接在compose文件中指定</li><li>镜像建议通过image，若为build将会每次都重新构建<br><img src="https://i.loli.net/2019/05/04/5ccd0605cbe19.png" alt="pycharm.docker-compose.png"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  centos:</span><br><span class="line">    # build:</span><br><span class="line">    #   context: .</span><br><span class="line">    #   dockerfile: Dockerfile.centos</span><br><span class="line">    image: zipee/centos:latest</span><br><span class="line">    command: sh</span><br><span class="line">    volumes:</span><br><span class="line">      - E:\code\python3\:/var/www/</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5000:5000&quot;</span><br><span class="line">    links:</span><br><span class="line">      - redis</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:alpine&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br></pre></td></tr></table></figure><h2 id="celery-remote-debug"><a href="#celery-remote-debug" class="headerlink" title="celery remote-debug"></a>celery remote-debug</h2><p>由于celery将不再支持windows，所以celery的调试就比较麻烦，有了远程调试后这个问题就迎刃而解</p><p>简单的celery代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line">app = Celery(&apos;simple&apos;, broker=&apos;redis://redis:6379/0&apos;)</span><br><span class="line"></span><br><span class="line">@app.task()</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure></p><p>配置celery的启动命令：<br><img src="https://i.loli.net/2019/05/04/5ccd0ebb7816c.png" alt="pycharm.celery.png"></p><p>使用了docker作为python远程解释器，甚至本地都无需安装python，使用起来简直不要太优雅！</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;pycharm是目前python开发者中最受欢迎的IDE，今天来介绍它的远程调试功能。&lt;br&gt;请注意文中介绍的所有功能仅出现在pycharm专业版版中。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="coding-tools" scheme="https://ziperlee.github.io/zipee.github.io/categories/coding-tools/"/>
    
    
      <category term="python" scheme="https://ziperlee.github.io/zipee.github.io/tags/python/"/>
    
      <category term="coding-tools" scheme="https://ziperlee.github.io/zipee.github.io/tags/coding-tools/"/>
    
  </entry>
  
  <entry>
    <title>flask分布式部署及flask-session</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/03/25/flask%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E5%8F%8Aflask-session/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/03/25/flask分布式部署及flask-session/</id>
    <published>2019-03-25T13:12:52.000Z</published>
    <updated>2019-04-27T00:02:24.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>随着业务系统访问量的增长，多机部署成了必然，下面来聊聊flask的分布式部署以及原理。</p></div><a id="more"></a><h3 id="flask默认的session做了什么"><a href="#flask默认的session做了什么" class="headerlink" title="flask默认的session做了什么"></a>flask默认的session做了什么</h3><p>flask作为web应用框架若多机部署，第一个问题是需要一个请求接入网关，通常我们使用nginx统一进行流量的分发。<br>但随之而来会有一个新的问题，即flask的session多机之间会共享吗？带着这个问题，我们看看flask关于session的源码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecureCookieSession</span><span class="params">(CallbackDict, SessionMixin)</span>:</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecureCookieSessionInterface</span><span class="params">(SessionInterface)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_session</span><span class="params">(self, app, request)</span>:</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_session</span><span class="params">(self, app, session, response)</span>:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>以上是flask.sessions.py实现的主要框架：</p><ul><li>SecureCookieSession即flask的session类，可以简单的理解成一个dict对象。</li><li>SecureCookieSessionInterface即flask的session接口类，open_session方法用于创建session，save_session方法用于将session加密并存放在response的cookie中。所以flask是默认将用户的session存储在客户端的cookie中，这样请求-应答的数据中就有了用户操作的上下文了，至于这么做的优劣将在下文分析。</li></ul><h3 id="常见的分布式部署session解决方案"><a href="#常见的分布式部署session解决方案" class="headerlink" title="常见的分布式部署session解决方案"></a>常见的分布式部署session解决方案</h3><ul><li>服务器间session复制<br>session复制是早期的企业级的使用比较多的一种服务器集群session管理机制。应用服务器开启web容器的session复制功能，在集群中的几台  服务器之间同步session对象，使得每台服务器上都保存所有的session信息，这样任何一台宕机都不会导致session的数据丢失，服务器使用session时，直接从本地获取。<br>像java的一些应用服务器，如tomcat等自带次功能。在python-web不常见，<code>缺点</code>是session同步会暂用内网网络带宽，且服务器水平扩展存在明显上线。</li><li>session与服务器绑定<br>通过请求网关，如nginx，将负载均衡的策略改成ip-hash的模式，即用户的每次请求都会分发到同一台服务器，那么sesison则能够正常的被解析。<br><code>优点</code>：无需修改业务代码<br><code>缺点</code>：缺乏高可用性，当其中一台服务器宕机，该机器上用户需要重新登录到其他服务器</li><li>客户端session存储<br>即flask默认的session存储方案，可见什么都不需要改动，flask已经支持水平扩展，细心的童鞋想想当flask通过gunicorn启动时多进程为啥能够共享session，即不难想到多个服务间共享应该也问题不大。这里注意的是多服务器间的secret_key必须相同。<br><code>优点</code>：无需改造，flask默认支持<br><code>缺点</code>：<ul><li>session数据存储在客户端，即使加密也还是一件存在泄露风险的事情</li><li>session数据占用外网带宽</li><li>受cookie的大小限制，session能记录的数据有限</li></ul></li><li>服务端session统一存储<br>对session进行统一的存储，所有服务器共享该存储服务上的数据<br><code>优点</code>：服务水平扩展性良好，服务端存储，安全<br><code>缺点</code>：<ul><li>每次请求至少需要一次内部网络请求，占用网络带宽</li><li>需要侵入业务代码</li></ul></li></ul><h3 id="flask-session服务端session存储"><a href="#flask-session服务端session存储" class="headerlink" title="flask-session服务端session存储"></a>flask-session服务端session存储</h3><p>通过比较不难发现，服务端session统一存储是最合适的解决方案。<br>那么我们来谈谈怎么实现，幸运的是已经有前任实现了flask对应的扩展包<code>flask-session</code>，我们一起看看它的实现：<br>代码大概500+行，但我们实际用到的可能就几十行。</p><ul><li>首先我们需要选择session寄存的服务，flask-session支持<code>redis</code>,<code>memcached</code>,<code>filesystem</code>,<code>mongodb</code>,<code>sqlalchemy</code>作为存储介质</li><li>以redis举例，再看代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisSessionInterface</span><span class="params">(SessionInterface)</span>:</span></span><br><span class="line">    serializer = pickle</span><br><span class="line">    session_class = RedisSession</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, redis, key_prefix, use_signer=False, permanent=True)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> redis <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line">            redis = Redis()</span><br><span class="line">        self.redis = redis</span><br><span class="line">        self.key_prefix = key_prefix</span><br><span class="line">        self.use_signer = use_signer</span><br><span class="line">        self.permanent = permanent</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_session</span><span class="params">(self, app, request)</span>:</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_session</span><span class="params">(self, app, session, response)</span>:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p>重写<code>open_session，save_session</code>，将session（dict）存储在redis并将session_id（key）返回给客户端</p><h3 id="flask-http请求-应答完整的数据流"><a href="#flask-http请求-应答完整的数据流" class="headerlink" title="flask http请求-应答完整的数据流"></a>flask http请求-应答完整的数据流</h3><p>客户端http请求<br>-&gt; 服务端负载均衡至随机服务器<br>-&gt; 应用上下文入栈(app_ctx)<br>-&gt; 请求上下文入栈(request_ctx),同时生成session<br>-&gt; 通过request_ctx中的路由信息找到视图函数(view_func)<br>-&gt; view_func进行业务处理<br>-&gt; 应用上下文出栈(app_ctx)<br>-&gt; 请求上下文出栈(request_ctx)<br>-&gt; 保存session或sessino_id进cookie<br>-&gt; 返回应答<br>-&gt; 数据写入对应的文件描述符并刷新<br>其实flask的源码阅读起来并不吃力，看下来会发现flask框架代码的思路结构非常的清晰，并惊叹于这个框架的可扩展性，flask的源码非常值得学习和借鉴。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;随着业务系统访问量的增长，多机部署成了必然，下面来聊聊flask的分布式部署以及原理。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="flask" scheme="https://ziperlee.github.io/zipee.github.io/categories/flask/"/>
    
    
      <category term="flask" scheme="https://ziperlee.github.io/zipee.github.io/tags/flask/"/>
    
      <category term="session" scheme="https://ziperlee.github.io/zipee.github.io/tags/session/"/>
    
      <category term="分布式" scheme="https://ziperlee.github.io/zipee.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>webserver异常-TooManyOpenFiles</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/03/10/webserver%E5%BC%82%E5%B8%B8-TooManyOpenFiles/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/03/10/webserver异常-TooManyOpenFiles/</id>
    <published>2019-03-10T09:32:36.000Z</published>
    <updated>2019-03-10T12:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题现象："><a href="#问题现象：" class="headerlink" title="问题现象："></a>问题现象：</h3><div class="note warning"><ul><li>webserver服务不可用</li><li>查询日志得知异常为”… Too Many Open Files”</li><li>重启webserver后服务正常可用</li></ul></div><a id="more"></a><hr><h3 id="问题环境："><a href="#问题环境：" class="headerlink" title="问题环境："></a>问题环境：</h3><div class="note info"><ul><li>使用nginx+gunicorn+flask搭建webserver的运行环境</li><li>环境进程文件句柄使用数上线未设置过为1024</li><li>gunicorn max-connections=2048 workers=9</li></ul></div><hr><h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><ol><li>ulimit -n 设置过小<ul><li>问题原因比较好定位，google一下大概就确定了</li><li>调大open files应该就可以了</li></ul></li><li>gunicorn max-connections指单个workers还是gunicorn整体的最大连接数？<ul><li>找了官方文档和google的博客均没细说，如果是前者那是有文件句柄不够用的可能性，而后者则可能性不大，最后还是自己看了源码并通过siege进行性能测试得出结论，<code>gunicorn max-connections指单个workers</code>。</li></ul></li></ol><hr><h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ul><li>根据性能测试调大open files，并对数据数值添加监控。</li></ul><hr><h3 id="问题总结："><a href="#问题总结：" class="headerlink" title="问题总结："></a>问题总结：</h3><ul><li><p><strong>linux open files</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 查看系统最大可打开文件数</span><br><span class="line">cat /proc/sys/fs/file-max</span><br><span class="line">2. 查看进程最大可打开文件数</span><br><span class="line">cat /etc/security/limits.conf</span><br><span class="line">3. 查看指定进程文件打开数</span><br><span class="line">lsof -p pid | wc -l </span><br><span class="line">4. 查看gunicorn fork出所有进程的文件打开数</span><br><span class="line">lsof -n|awk &apos;&#123;print $1&#125;&apos;|sort|uniq -c|sort -nr|grep gunicorn</span><br><span class="line">5. 进程 fork() 出来的子进程，会继承父进程的 limits 设定</span><br></pre></td></tr></table></figure></li><li><p><strong>gunicorn</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. work_connections指gunicorn单进程并发数</span><br><span class="line">2. 若gunicorn worker_connections &lt; 当前并发数，请求至多会超时，而不会报连接文件句柄异常</span><br><span class="line">3、当worker_connections &gt; 1 时 且程序可异步操作越久（sleep），gevent作用越明显</span><br></pre></td></tr></table></figure></li><li><p><strong>异常再次发生处理步骤</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. ps -ef |grep gunicorn -&gt; pid</span><br><span class="line">2. cat /proc/pid/limits.conf</span><br><span class="line">3. lsof -p pid |wc -l</span><br><span class="line">4. sudo vi  /etc/security/limits.conf</span><br><span class="line">asset soft nofile 10240</span><br><span class="line">asset hard nofile 10240</span><br><span class="line">5. restart program &amp;&amp; cat /proc/pid/limits.conf</span><br></pre></td></tr></table></figure></li><li><p><strong>性能测试</strong></p><ol><li>性能测试主要使用了siege和locust，siege通过创建线程进行并发对测试机的影响较大，而locust通过协程并发请求，测试并发数能更高，该部分的具体内容会另起篇幅进行总结梳理。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题现象：&quot;&gt;&lt;a href=&quot;#问题现象：&quot; class=&quot;headerlink&quot; title=&quot;问题现象：&quot;&gt;&lt;/a&gt;问题现象：&lt;/h3&gt;&lt;div class=&quot;note warning&quot;&gt;&lt;ul&gt;
&lt;li&gt;webserver服务不可用&lt;/li&gt;
&lt;li&gt;查询日志得知异常为”… Too Many Open Files”&lt;/li&gt;
&lt;li&gt;重启webserver后服务正常可用&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="问题分析" scheme="https://ziperlee.github.io/zipee.github.io/categories/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
    
      <category term="问题分析" scheme="https://ziperlee.github.io/zipee.github.io/tags/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="flask" scheme="https://ziperlee.github.io/zipee.github.io/tags/flask/"/>
    
      <category term="linux" scheme="https://ziperlee.github.io/zipee.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>sqlalchemy数据库连接数异常</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/01/22/sqlalchemy%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%95%B0%E5%BC%82%E5%B8%B8/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/01/22/sqlalchemy数据库连接数异常/</id>
    <published>2019-01-22T13:03:19.000Z</published>
    <updated>2019-03-10T12:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题现象："><a href="#问题现象：" class="headerlink" title="问题现象："></a>问题现象：</h3><div class="note warning"><ul><li>web端调用flask接口阻塞，最终超时返回系统异常</li><li>查询日志得知具体异常为超出数据库最大连接数</li><li>重新flask webserver后数据库连接数正常释放</li><li>持续使用系统一段时间后数据库连接数再次封顶</li><li>环境操作用户寥寥无几</li></ul></div><a id="more"></a><hr><h3 id="问题环境："><a href="#问题环境：" class="headerlink" title="问题环境："></a>问题环境：</h3><div class="note info"><ul><li>使用flask搭建webserver的运行环境</li><li>使用flask-sqlalchemy连接数据库并进行相关业务操作，SQLALCHEMY_POOL_SIZE = 64， SQLALCHEMY_POOL_RECYCLE = 30</li><li>mysql设置最大连接数200</li><li>宿主机CPU 2核心</li><li>通过进程数2*2+1 = 5</li></ul></div><hr><h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><ol><li><p>怀疑对flask-sqlalchemy使用不当导致</p><ul><li>问题原因明显是数据库连接使用后没有释放</li><li>数据库操作业务层均使用封装的方法，不存在操作对数据库的连接和释放</li><li>flask-sqlalchemy的连接释放由<code>teardown_appcontext</code>钩子统一处理<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.teardown_appcontext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shutdown_session</span><span class="params">(response_or_exc)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> app.config[<span class="string">'SQLALCHEMY_COMMIT_ON_TEARDOWN'</span>]:</span><br><span class="line">        <span class="keyword">if</span> response_or_exc <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.session.commit()</span><br><span class="line"></span><br><span class="line">    self.session.remove()</span><br><span class="line">    <span class="keyword">return</span> response_or_exc</span><br></pre></td></tr></table></figure></li></ul></li><li><p>mysql数据库连接超出首因</p><ul><li>(2*2+1) * 64 &gt; 200 </li><li>困惑连接数回收已经指定<code>SQLALCHEMY_POOL_RECYCLE=30</code>但未生效</li><li>对<code>SQLALCHEMY_POOL_RECYCLE</code>理解错误，该项真实含义为queue_pool可用连接的回收时间</li><li>当前问题为连接未释放，顾与<code>SQLALCHEMY_POOL_RECYCLE</code>无关</li></ul></li><li>若(2*2+1) * 64 &lt; 200 会不会好点？<ul><li>异常改为<code>QueuePool limit of size &lt;x&gt; overflow &lt;y&gt; reached, connection timed out, timeout &lt;z&gt;</code></li><li>达到queue_pool的最大限制后同样是无法连接数据库，只是换了种“死法”</li></ul></li></ol><p><strong>分析到这里仍旧没有头绪…</strong></p><hr><h3 id="问题排查："><a href="#问题排查：" class="headerlink" title="问题排查："></a>问题排查：</h3><ul><li><p><strong>查询数据库连接数</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA. PROCESSLIST</span><br></pre></td></tr></table></figure></li><li><p><strong>linux下查询连接端口对应的进程</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:48057|grep celery|awk   '&#123;print$2&#125;'|xargs -I&#123;&#125; echo 'ps -ef|grep &#123;&#125;'|bash</span><br></pre></td></tr></table></figure></li><li><p><strong>windows下查询连接端口对应的进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano|findstr "8080"</span><br><span class="line">tasklist|findstr [进程号]</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ul><li>问题调试发现单接口调用连接数并未按预期增长</li><li>通过页面使用操作连接数会不规则的增长</li><li>逐个接口比对，最终发现在调用sse长连接接口后，连接数会稳定增长1</li><li>分析sse仅操作了redis，并未存在对mysql的相关操作</li><li>调试发现调用sse会进入@after_request请求钩子中，而在该钩子处理函数中使用了current_user，即调用了数据库</li><li>到此真相大白，代码修改很简单过滤该url既可，但问题的思考排查真实饶了一大圈</li></ul><hr><h3 id="问题总结："><a href="#问题总结：" class="headerlink" title="问题总结："></a>问题总结：</h3><ul><li>最后反思，其实在确定flask-sqlalchemy框架层在正常api逻辑处理中会自动释放连接后，就应该直接猜测是非业务短连接接口导致，但这其中的盲点主要在sse正常情况下是与mysql毫不相干的，顾很容易忽略sse的长连接问题</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题现象：&quot;&gt;&lt;a href=&quot;#问题现象：&quot; class=&quot;headerlink&quot; title=&quot;问题现象：&quot;&gt;&lt;/a&gt;问题现象：&lt;/h3&gt;&lt;div class=&quot;note warning&quot;&gt;&lt;ul&gt;
&lt;li&gt;web端调用flask接口阻塞，最终超时返回系统异常&lt;/li&gt;
&lt;li&gt;查询日志得知具体异常为超出数据库最大连接数&lt;/li&gt;
&lt;li&gt;重新flask webserver后数据库连接数正常释放&lt;/li&gt;
&lt;li&gt;持续使用系统一段时间后数据库连接数再次封顶&lt;/li&gt;
&lt;li&gt;环境操作用户寥寥无几&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="问题分析" scheme="https://ziperlee.github.io/zipee.github.io/categories/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
    
      <category term="mysql" scheme="https://ziperlee.github.io/zipee.github.io/tags/mysql/"/>
    
      <category term="问题分析" scheme="https://ziperlee.github.io/zipee.github.io/tags/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>python代码pyc化加密部署</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2018/12/30/python%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86%E9%83%A8%E7%BD%B2/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2018/12/30/python代码加密部署/</id>
    <published>2018-12-30T08:45:56.000Z</published>
    <updated>2018-12-30T09:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>python不像c，java等编译型语言（编译后发布机器码），解释型则必须把源码发布出去，但仍存在一些交付场景希望能够将python代码加密。</p></div><a id="more"></a><h3 id="为什么转换为pyc？"><a href="#为什么转换为pyc？" class="headerlink" title="为什么转换为pyc？"></a>为什么转换为pyc？</h3><ul><li>pyc官方的解释还请自行google</li><li>简而言之，pyc文件为字节码文件，单个.py生成.pyc文件后运行效果相同</li><li>pyc文件运行效率高于py文件（少了解释器对源码的转换）</li><li>pyc虽然可以进行逆向转换，但不一定可靠（没试过），不过已经满足了简单加密的需求，毕竟源码裸奔交付是心理上不能接收的</li></ul><h3 id="如何转换为pyc？"><a href="#如何转换为pyc？" class="headerlink" title="如何转换为pyc？"></a>如何转换为pyc？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m compileall (file or dir) -b</span><br></pre></td></tr></table></figure><ul><li>-b 支持生成pyc文件于当前目录而非<code>__pycache__</code></li></ul><h3 id="配合jenkins进行自动集成发布"><a href="#配合jenkins进行自动集成发布" class="headerlink" title="配合jenkins进行自动集成发布"></a>配合jenkins进行自动集成发布</h3><ul><li>基于flask开发目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/app</span><br><span class="line">/conf</span><br><span class="line">/tests</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> /bin/sh</span><br><span class="line"></span><br><span class="line">function timeoutController()&#123;</span><br><span class="line">    cmd=$1</span><br><span class="line">    timeout=$2</span><br><span class="line">    mod=$3</span><br><span class="line">    count=1</span><br><span class="line">    while [ $count -le 3 ]; do</span><br><span class="line">        timeout $timeout $cmd</span><br><span class="line">        exitCode=$?</span><br><span class="line">        if [[ $exitCode == 0 ]] || [[ $exitCode -ne 124 ]]; then</span><br><span class="line">            break</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        if [ $exitCode == 124 ]; then</span><br><span class="line">            echo "module: &#123;$mod&#125; timeout &#123;$timeout&#125; s and start to &#123;$count&#125; time retry"</span><br><span class="line">        fi</span><br><span class="line">        count=`expr $count + 1`</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    if [ $exitCode -ne 0 ]; then</span><br><span class="line">        echo $mod "=====================&gt;unittest failed"</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function code_encrypt()&#123;</span><br><span class="line">    release_dir=$1</span><br><span class="line">    pyc_dir=$2</span><br><span class="line"></span><br><span class="line">    # release svn del .svn</span><br><span class="line">    find $release_dir -name ".svn" | xargs rm -rf</span><br><span class="line"></span><br><span class="line">    # svn del pyc</span><br><span class="line">    cd $pyc_dir</span><br><span class="line">    svn rm * --force</span><br><span class="line">    svn ci -m "pyc delete"</span><br><span class="line"></span><br><span class="line">    # cp release code to pyc &amp;&amp; encrypt code</span><br><span class="line">    cp $release_dir/* $pyc_dir -R</span><br><span class="line">    python -m compileall . -b</span><br><span class="line">    find . -name "*.py" | xargs rm</span><br><span class="line">    rm tests/report -rf</span><br><span class="line">    # replace gunicorn.pyc with gunicorn.py</span><br><span class="line">    rm $pyc_dir/conf/gunicorn.pyc</span><br><span class="line">    cp $release_dir/conf/gunicorn.py $pyc_dir/conf/</span><br><span class="line"></span><br><span class="line">    # pyc svn commit</span><br><span class="line">    svn add . --no-ignore --force</span><br><span class="line">    svn ci -m "pyc commit"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()&#123;</span><br><span class="line">    echo "========================== init env ============="</span><br><span class="line">    source /root/anaconda3/bin/activate py3</span><br><span class="line">    release_dir="/home/pro/pro_release"</span><br><span class="line">    pyc_dir="/home/pro/pro_pyc"</span><br><span class="line">    release_svn_dir="http://*.*.*.*/"</span><br><span class="line"></span><br><span class="line">    # update tag:release code</span><br><span class="line">    rm $release_dir -rf</span><br><span class="line">    svn co $release_svn_dir</span><br><span class="line"></span><br><span class="line">    echo "========================== flake8 ==============="</span><br><span class="line">    cd $release_dir</span><br><span class="line">    timeoutController "flake8 --config=$&#123;release_dir&#125;/.config/flake8 $&#123;release_dir&#125;" 60 "flake8"</span><br><span class="line"></span><br><span class="line">    echo "========================== pytest ==============="</span><br><span class="line">    cd $release_dir/tests</span><br><span class="line">    timeoutController "pytest ."</span><br><span class="line"></span><br><span class="line">    echo "========================== code encrypt ============="</span><br><span class="line">    code_encrypt $release_dir $pyc_dir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main</span><br></pre></td></tr></table></figure><div class="note warning"><ul><li>以上脚本基于svn代码管理，如使用git，则flake8，pytest测试可通过git hook，而单单保留代码加密</li><li>gunicorn 貌似不支持指定pyc为配置文件，但这不影响整体的加密效果，后续可以在研究研究，毕竟对于我这种重度洁癖患者，留这一个.py文件就像一个小疙瘩，总想给它挠掉</li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;python不像c，java等编译型语言（编译后发布机器码），解释型则必须把源码发布出去，但仍存在一些交付场景希望能够将python代码加密。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="python" scheme="https://ziperlee.github.io/zipee.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://ziperlee.github.io/zipee.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>flask服务端推送</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2018/11/25/flask%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2018/11/25/flask服务端推送/</id>
    <published>2018-11-25T07:09:26.000Z</published>
    <updated>2018-11-25T08:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文用以记录在<code>flask-sse</code>使用中踩到的坑及解决方案。</p></div><a id="more"></a><h3 id="当前主流的服务端推送方案"><a href="#当前主流的服务端推送方案" class="headerlink" title="当前主流的服务端推送方案"></a>当前主流的服务端推送方案</h3><ol><li>客户端短连接轮询</li><li>websocket</li><li>Server Send Event（SSE）</li></ol><p>相较于轮询的方式，websocket和sse会稍显高级而不是无脑的轮询浪费网络资源。<br>在最近一次的方案选型中，我选择了sse，理由是websocket是双工，且需要单独的服务，而项目的需求仅是向客户端进行简单的推送信息，对比之下sse更显轻量且开发量更少。</p><hr><h3 id="使用过程中遇到的困难"><a href="#使用过程中遇到的困难" class="headerlink" title="使用过程中遇到的困难"></a>使用过程中遇到的困难</h3><ul><li><p><strong><code>flask-sse</code> redis连接释放问题</strong><br>该库目前存在缺陷，当浏览器刷新或者网关断开重连时会重新<code>new EventSource</code>，然而服务端并无法得知连接的断开，导致redis连接数会一直增加。<br>唯一释放的机会在于当再次收到推送信息，协程被唤醒并产生<code>GeneratorExit</code>异常<br>因此代码中未对异常捕获，将错过最后一次释放reids连接的机会：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@stream_with_context</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> message <span class="keyword">in</span> self.messages(channel=channel):</span><br><span class="line">        <span class="keyword">yield</span> str(message)</span><br><span class="line">        self.redis.connection_pool.disconnect()</span><br></pre></td></tr></table></figure><p>  修改的代码已上传github，并提交merge，但是由于没有通过python2的测试用例导致未被合并（懒得适配），有兴趣的童鞋可以直接查看我fork提交的代码。</p><p>  <code>redis连接数查看</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a pwd -h *.*.*.* info | grep client</span><br></pre></td></tr></table></figure></li><li><p><strong>程序阻塞问题</strong><br>由于最开始使用之前未仔细看官方的实用说明和源码，发现uwsgi实用进程线程的启动模式，程序运行几次之后就阻塞了，最后发现正确的打开方式是使用协程的方式驱动http服务。</p><p>  另外还有一点现象，当使用flask自带的http服务器进行多线程<code>threaded=True</code>调试时redis连接能一次性释放掉，而当使用gunicorn+gevent方式运行时却没有一步到位的效果，原因是协程是异步的，一次<code>最多</code>能唤醒对应进程数量的协程，所以redis的释放问题最终还是需要通过定时推送心跳包的方式解决，推荐使用<code>celery</code>。</p></li><li><p><strong>网关超时问题</strong><br>网关基本都会有超时设置，而浏览器的断线重连貌似对于504的异常并不起作用。<br>  因此需要针对超时异常进行特殊处理。<br>  这里给出<a href="https://github.com/BotBotMe/botbot-web/issues/2" target="_blank" rel="noopener">nginx配置</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /eventsource &#123;</span><br><span class="line">include uwsgi_params;</span><br><span class="line">uwsgi_pass eventsource-botbot-backend;</span><br><span class="line">uwsgi_buffering off;</span><br><span class="line">chunked_transfer_encoding off;</span><br><span class="line">proxy_cache off;</span><br><span class="line">access_log  /var/log/nginx/eventsource_botbot.access.log;</span><br><span class="line">error_page 504 =200 @eventsource-close-graceful;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location @eventsource-close-graceful &#123;</span><br><span class="line">add_header Content-Type text/event-stream;</span><br><span class="line">return 200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>注意</code>每个nginx网关就需要配置</p></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/singingwolfboy/flask-sse" target="_blank" rel="noopener">官方用例</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文用以记录在&lt;code&gt;flask-sse&lt;/code&gt;使用中踩到的坑及解决方案。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="flask" scheme="https://ziperlee.github.io/zipee.github.io/categories/flask/"/>
    
    
      <category term="flask" scheme="https://ziperlee.github.io/zipee.github.io/tags/flask/"/>
    
      <category term="sse" scheme="https://ziperlee.github.io/zipee.github.io/tags/sse/"/>
    
  </entry>
  
  <entry>
    <title>win10docker使用填坑</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2018/11/04/win10docker%E4%BD%BF%E7%94%A8%E5%A1%AB%E5%9D%91/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2018/11/04/win10docker使用填坑/</id>
    <published>2018-11-04T05:17:09.000Z</published>
    <updated>2018-11-04T13:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文用以记录在<code>docker win10</code>环境使用中踩到的坑及解决方案。</p></div><a id="more"></a><h2 id="问题一：docker修改配置或者镜像的存储位置后启动异常"><a href="#问题一：docker修改配置或者镜像的存储位置后启动异常" class="headerlink" title="问题一：docker修改配置或者镜像的存储位置后启动异常"></a>问题一：docker修改配置或者镜像的存储位置后启动异常</h2><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><em>解决方案</em>：</h3><div class="note warning"><ul><li>移动|剪切 C:\Users\Public\Documents\Hyper-V\Virtual hard disks\MobyLinuxVM.vhdx 再重启电脑</li></ul></div><hr><h2 id="问题二：修改镜像存储位置"><a href="#问题二：修改镜像存储位置" class="headerlink" title="问题二：修改镜像存储位置"></a>问题二：修改镜像存储位置</h2><h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a><em>解决方案</em>：</h3><div class="note warning"><ul><li>默认位置：C:\Users\Public\Documents\Hyper-V\Virtual hard disks\MobyLinuxVM.vhdx</li><li>修改：Hyper-V管理器<strong>Hyper-v设置</strong>虚拟硬盘修改路径</li></ul></div><hr><h2 id="问题三：docker安装mysql8-0容器后，是用navicat连接报client-does-not-support-authentication-protocol-requested-by-server-consider-upgrading-mysql-client"><a href="#问题三：docker安装mysql8-0容器后，是用navicat连接报client-does-not-support-authentication-protocol-requested-by-server-consider-upgrading-mysql-client" class="headerlink" title="问题三：docker安装mysql8.0容器后，是用navicat连接报client does not support authentication protocol requested by server consider upgrading mysql client"></a>问题三：docker安装mysql8.0容器后，是用navicat连接报client does not support authentication protocol requested by server consider upgrading mysql client</h2><h3 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a><em>解决方案</em>：</h3><div class="note warning"><ul><li>进入容器<br>docker exec -it mysql bash</li><li>进入mysql<br>mysql -u root -p</li><li>创建root用户<br>CREATE USER ‘root‘@’%’ IDENTIFIED IDENTIFIED WITH <code>mysql_native_password</code> BY ‘123456’;</li><li>设置root用户访问权限<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root‘@’%’ WITH GRANT OPTION;</li><li>重置密码<br>ALTER USER ‘root‘@’%’ IDENTIFIED WITH <code>mysql_native_password</code> BY ‘123456’;<br>ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH <code>mysql_native_password</code> BY ‘123456’;</li><li>提交修改<br>FLUSH PRIVILEGES;</li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文用以记录在&lt;code&gt;docker win10&lt;/code&gt;环境使用中踩到的坑及解决方案。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="docker" scheme="https://ziperlee.github.io/zipee.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://ziperlee.github.io/zipee.github.io/tags/docker/"/>
    
      <category term="wins10" scheme="https://ziperlee.github.io/zipee.github.io/tags/wins10/"/>
    
  </entry>
  
</feed>
