<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zipee&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ziperlee.github.io/zipee.github.io/"/>
  <updated>2019-06-16T08:19:01.120Z</updated>
  <id>https://ziperlee.github.io/zipee.github.io/</id>
  
  <author>
    <name>Zipee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法总结</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/06/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/06/16/数据结构与算法总结/</id>
    <published>2019-06-16T08:02:18.000Z</published>
    <updated>2019-06-16T08:19:01.120Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>总结下算法与数据结构的基础知识，虽然网络上有现成的总结，但拿来主义不是学习编程该走的捷径。</p></div><a id="more"></a><h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p><img src="https://i.loli.net/2019/06/16/5d05fac1bcc8e83459.png" alt="优劣示意图.png"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://i.loli.net/2019/06/16/5d05fac1e674389225.png" alt="数据结构复杂度.png"></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><img src="https://i.loli.net/2019/06/16/5d05fac1d4a8f86311.png" alt="排序复杂度.png"></p><h2 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h2><p><img src="https://i.loli.net/2019/06/16/5d05fac19111547738.png" alt="堆.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;总结下算法与数据结构的基础知识，虽然网络上有现成的总结，但拿来主义不是学习编程该走的捷径。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="algorithm&amp;datastructure" scheme="https://ziperlee.github.io/zipee.github.io/categories/algorithm-datastructure/"/>
    
    
      <category term="algorithm" scheme="https://ziperlee.github.io/zipee.github.io/tags/algorithm/"/>
    
      <category term="datastructure" scheme="https://ziperlee.github.io/zipee.github.io/tags/datastructure/"/>
    
  </entry>
  
  <entry>
    <title>python程序员开发规范</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/06/09/python%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/06/09/python程序员开发规范/</id>
    <published>2019-06-09T07:12:51.000Z</published>
    <updated>2019-06-09T08:49:37.224Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文介绍两个python开发工具（flake8，black），并结合pycharm，pre-commit进行使用。</p></div><a id="more"></a><h2 id="flake8"><a href="#flake8" class="headerlink" title="flake8"></a>flake8</h2><ul><li>基于PEP8的静态代码检查工具。有助于约束团队使用统一的代码规范。</li><li>安装 <code>pip install flake8</code></li><li>指定文件检查 <code>flake8 path/code.py</code></li><li>指定目录检查 <code>flake8 path</code></li><li>忽略指定错误 <code>flake8 --ignore E24,W504 path</code></li><li>指定配置文件 <code>flake8 --config path1/.flake8 path2 （linux下默认查找用户目录）</code></li><li>代码指定行忽略检查 <code># noqa</code></li><li><a href="https://lintlyci.github.io/Flake8Rules/" target="_blank" rel="noopener">异常快速定位</a></li></ul><p><strong>配置文件模版</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[flake8]</span><br><span class="line">ignore =</span><br><span class="line">    E203 # whitespace before &apos;:&apos;</span><br><span class="line">    E741 # ambiguous variable name &apos;l&apos;</span><br><span class="line">filename =</span><br><span class="line">exclude =</span><br><span class="line">max-line-length = 89</span><br><span class="line">max-complexity = 10  # 指定代码最高复杂度</span><br></pre></td></tr></table></figure></p><p><strong>windows下配合pycharm使用</strong>：<br><code>File-&gt;Settings-&gt;Tools-&gt;External Tools-&gt;add</code><br><img src="https://i.loli.net/2019/06/09/5cfcc0aac588786191.png" alt="pycharm.flake8.png"></p><h2 id="black"><a href="#black" class="headerlink" title="black"></a>black</h2><ul><li>flake8经常会检查出代码格式上的异常，手动修改实在烦人，这时候推荐使用这款自动格式化代码神器，从此团队code review只需要关注代码业务逻辑</li><li>基本不需要自定义配置文件（虽然支持），相较于pylint需要各种自定义设置，black的极简哲学让我想到了iphone，”产品来告诉你你真正想要的”（产品决定需求）</li><li>安装 <code>pip install black</code></li><li>black –diff path/code.py <code>输出格式化差异</code></li><li>black path/code.py <code>自动格式代码</code>（简单暴力）</li></ul><p><strong>windows下配合pycharm使用</strong>：<br><code>File-&gt;Settings-&gt;Tools-&gt;External Tools-&gt;add</code><br><img src="https://i.loli.net/2019/06/09/5cfcc0aac58b837834.png" alt="pycharm.black.png"></p><h2 id="配合使用pre-commit"><a href="#配合使用pre-commit" class="headerlink" title="配合使用pre-commit"></a>配合使用pre-commit</h2><ul><li>安装 <code>pip install pre_commit</code></li><li>创建配置文件 <code>touch .pre-commit-config.yaml</code></li><li>初始化 <code>pre-commit install</code></li><li>垃圾回收 <code>pre-commit gc</code></li></ul><p><strong>配置模版</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">repos:</span><br><span class="line">-   repo: https://github.com/ambv/black</span><br><span class="line">    rev: stable</span><br><span class="line">    hooks:</span><br><span class="line">    - id: black</span><br><span class="line">      language_version: python3.6</span><br><span class="line">-   repo: https://github.com/pre-commit/pre-commit-hooks</span><br><span class="line">    rev: v2.2.3</span><br><span class="line">    hooks:</span><br><span class="line">    - id: flake8</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文介绍两个python开发工具（flake8，black），并结合pycharm，pre-commit进行使用。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://ziperlee.github.io/zipee.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pycharm远程调试</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/04/27/pycharm%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/04/27/pycharm远程调试/</id>
    <published>2019-04-27T00:00:34.000Z</published>
    <updated>2019-05-04T04:05:29.038Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>pycharm是目前python开发者中最受欢迎的IDE，今天来介绍它的远程调试功能。<br>请注意文中介绍的所有功能仅出现在pycharm专业版版中。</p></div><a id="more"></a><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><ul><li><code>File</code>-&gt;<code>Settings</code>-&gt;<code>Project</code>-&gt;<code>Project Interpreter</code>-&gt;<code>add</code></li><li>配置mapping，本地代码与远程代码的映射，<code>此步骤是必须的</code>，方式可以通过挂载或者Tool-&gt;Configure-&gt;SFTP</li><li>Interpreter设置完后请确认<code>External Libraries</code>-&gt;<code>Remote Libraries</code>生成，若未出现，重启pycharm或许有奇迹</li></ul><h2 id="SSL-Interpreter"><a href="#SSL-Interpreter" class="headerlink" title="SSL Interpreter"></a>SSL Interpreter</h2><p><img src="https://i.loli.net/2019/05/04/5ccd05b56616c.png" alt="pycharm.ssh.png"></p><p>这里需要注意远程的运行环境必须是venv|virtualenv，若使用conda将导致无法获取<code>Remote Libraries</code>，从而无法远程debug</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul><li>开启docker守护进程的API调用</li><li>mapping需要另外挂载<br><img src="https://i.loli.net/2019/05/04/5ccd06162dfdb.png" alt="pycharm.docker.png"></li></ul><h2 id="Docker-Compose（推荐）"><a href="#Docker-Compose（推荐）" class="headerlink" title="Docker Compose（推荐）"></a>Docker Compose（推荐）</h2><ul><li>mapping挂载可以直接在compose文件中指定</li><li>镜像建议通过image，若为build将会每次都重新构建<br><img src="https://i.loli.net/2019/05/04/5ccd0605cbe19.png" alt="pycharm.docker-compose.png"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  centos:</span><br><span class="line">    # build:</span><br><span class="line">    #   context: .</span><br><span class="line">    #   dockerfile: Dockerfile.centos</span><br><span class="line">    image: zipee/centos:latest</span><br><span class="line">    command: sh</span><br><span class="line">    volumes:</span><br><span class="line">      - E:\code\python3\:/var/www/</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5000:5000&quot;</span><br><span class="line">    links:</span><br><span class="line">      - redis</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:alpine&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br></pre></td></tr></table></figure><h2 id="celery-remote-debug"><a href="#celery-remote-debug" class="headerlink" title="celery remote-debug"></a>celery remote-debug</h2><p>由于celery将不再支持windows，所以celery的调试就比较麻烦，有了远程调试后这个问题就迎刃而解</p><p>简单的celery代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line">app = Celery(&apos;simple&apos;, broker=&apos;redis://redis:6379/0&apos;)</span><br><span class="line"></span><br><span class="line">@app.task()</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure></p><p>配置celery的启动命令：<br><img src="https://i.loli.net/2019/05/04/5ccd0ebb7816c.png" alt="pycharm.celery.png"></p><p>使用了docker作为python远程解释器，甚至本地都无需安装python，使用起来简直不要太优雅！</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;pycharm是目前python开发者中最受欢迎的IDE，今天来介绍它的远程调试功能。&lt;br&gt;请注意文中介绍的所有功能仅出现在pycharm专业版版中。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="coding-tools" scheme="https://ziperlee.github.io/zipee.github.io/categories/coding-tools/"/>
    
    
      <category term="python" scheme="https://ziperlee.github.io/zipee.github.io/tags/python/"/>
    
      <category term="coding-tools" scheme="https://ziperlee.github.io/zipee.github.io/tags/coding-tools/"/>
    
  </entry>
  
  <entry>
    <title>flask分布式部署及flask-session</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/03/25/flask%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E5%8F%8Aflask-session/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/03/25/flask分布式部署及flask-session/</id>
    <published>2019-03-25T13:12:52.000Z</published>
    <updated>2019-04-27T00:02:24.727Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>随着业务系统访问量的增长，多机部署成了必然，下面来聊聊flask的分布式部署以及原理。</p></div><a id="more"></a><h3 id="flask默认的session做了什么"><a href="#flask默认的session做了什么" class="headerlink" title="flask默认的session做了什么"></a>flask默认的session做了什么</h3><p>flask作为web应用框架若多机部署，第一个问题是需要一个请求接入网关，通常我们使用nginx统一进行流量的分发。<br>但随之而来会有一个新的问题，即flask的session多机之间会共享吗？带着这个问题，我们看看flask关于session的源码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecureCookieSession</span><span class="params">(CallbackDict, SessionMixin)</span>:</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecureCookieSessionInterface</span><span class="params">(SessionInterface)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_session</span><span class="params">(self, app, request)</span>:</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_session</span><span class="params">(self, app, session, response)</span>:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>以上是flask.sessions.py实现的主要框架：</p><ul><li>SecureCookieSession即flask的session类，可以简单的理解成一个dict对象。</li><li>SecureCookieSessionInterface即flask的session接口类，open_session方法用于创建session，save_session方法用于将session加密并存放在response的cookie中。所以flask是默认将用户的session存储在客户端的cookie中，这样请求-应答的数据中就有了用户操作的上下文了，至于这么做的优劣将在下文分析。</li></ul><h3 id="常见的分布式部署session解决方案"><a href="#常见的分布式部署session解决方案" class="headerlink" title="常见的分布式部署session解决方案"></a>常见的分布式部署session解决方案</h3><ul><li>服务器间session复制<br>session复制是早期的企业级的使用比较多的一种服务器集群session管理机制。应用服务器开启web容器的session复制功能，在集群中的几台  服务器之间同步session对象，使得每台服务器上都保存所有的session信息，这样任何一台宕机都不会导致session的数据丢失，服务器使用session时，直接从本地获取。<br>像java的一些应用服务器，如tomcat等自带次功能。在python-web不常见，<code>缺点</code>是session同步会暂用内网网络带宽，且服务器水平扩展存在明显上线。</li><li>session与服务器绑定<br>通过请求网关，如nginx，将负载均衡的策略改成ip-hash的模式，即用户的每次请求都会分发到同一台服务器，那么sesison则能够正常的被解析。<br><code>优点</code>：无需修改业务代码<br><code>缺点</code>：缺乏高可用性，当其中一台服务器宕机，该机器上用户需要重新登录到其他服务器</li><li>客户端session存储<br>即flask默认的session存储方案，可见什么都不需要改动，flask已经支持水平扩展，细心的童鞋想想当flask通过gunicorn启动时多进程为啥能够共享session，即不难想到多个服务间共享应该也问题不大。这里注意的是多服务器间的secret_key必须相同。<br><code>优点</code>：无需改造，flask默认支持<br><code>缺点</code>：<ul><li>session数据存储在客户端，即使加密也还是一件存在泄露风险的事情</li><li>session数据占用外网带宽</li><li>受cookie的大小限制，session能记录的数据有限</li></ul></li><li>服务端session统一存储<br>对session进行统一的存储，所有服务器共享该存储服务上的数据<br><code>优点</code>：服务水平扩展性良好，服务端存储，安全<br><code>缺点</code>：<ul><li>每次请求至少需要一次内部网络请求，占用网络带宽</li><li>需要侵入业务代码</li></ul></li></ul><h3 id="flask-session服务端session存储"><a href="#flask-session服务端session存储" class="headerlink" title="flask-session服务端session存储"></a>flask-session服务端session存储</h3><p>通过比较不难发现，服务端session统一存储是最合适的解决方案。<br>那么我们来谈谈怎么实现，幸运的是已经有前任实现了flask对应的扩展包<code>flask-session</code>，我们一起看看它的实现：<br>代码大概500+行，但我们实际用到的可能就几十行。</p><ul><li>首先我们需要选择session寄存的服务，flask-session支持<code>redis</code>,<code>memcached</code>,<code>filesystem</code>,<code>mongodb</code>,<code>sqlalchemy</code>作为存储介质</li><li>以redis举例，再看代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisSessionInterface</span><span class="params">(SessionInterface)</span>:</span></span><br><span class="line">    serializer = pickle</span><br><span class="line">    session_class = RedisSession</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, redis, key_prefix, use_signer=False, permanent=True)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> redis <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line">            redis = Redis()</span><br><span class="line">        self.redis = redis</span><br><span class="line">        self.key_prefix = key_prefix</span><br><span class="line">        self.use_signer = use_signer</span><br><span class="line">        self.permanent = permanent</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_session</span><span class="params">(self, app, request)</span>:</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_session</span><span class="params">(self, app, session, response)</span>:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><p>重写<code>open_session，save_session</code>，将session（dict）存储在redis并将session_id（key）返回给客户端</p><h3 id="flask-http请求-应答完整的数据流"><a href="#flask-http请求-应答完整的数据流" class="headerlink" title="flask http请求-应答完整的数据流"></a>flask http请求-应答完整的数据流</h3><p>客户端http请求<br>-&gt; 服务端负载均衡至随机服务器<br>-&gt; 应用上下文入栈(app_ctx)<br>-&gt; 请求上下文入栈(request_ctx),同时生成session<br>-&gt; 通过request_ctx中的路由信息找到视图函数(view_func)<br>-&gt; view_func进行业务处理<br>-&gt; 应用上下文出栈(app_ctx)<br>-&gt; 请求上下文出栈(request_ctx)<br>-&gt; 保存session或sessino_id进cookie<br>-&gt; 返回应答<br>-&gt; 数据写入对应的文件描述符并刷新<br>其实flask的源码阅读起来并不吃力，看下来会发现flask框架代码的思路结构非常的清晰，并惊叹于这个框架的可扩展性，flask的源码非常值得学习和借鉴。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;随着业务系统访问量的增长，多机部署成了必然，下面来聊聊flask的分布式部署以及原理。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="flask" scheme="https://ziperlee.github.io/zipee.github.io/categories/flask/"/>
    
    
      <category term="flask" scheme="https://ziperlee.github.io/zipee.github.io/tags/flask/"/>
    
      <category term="session" scheme="https://ziperlee.github.io/zipee.github.io/tags/session/"/>
    
      <category term="分布式" scheme="https://ziperlee.github.io/zipee.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>webserver异常-TooManyOpenFiles</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/03/10/webserver%E5%BC%82%E5%B8%B8-TooManyOpenFiles/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/03/10/webserver异常-TooManyOpenFiles/</id>
    <published>2019-03-10T09:32:36.000Z</published>
    <updated>2019-03-10T12:09:14.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题现象："><a href="#问题现象：" class="headerlink" title="问题现象："></a>问题现象：</h3><div class="note warning"><ul><li>webserver服务不可用</li><li>查询日志得知异常为”… Too Many Open Files”</li><li>重启webserver后服务正常可用</li></ul></div><a id="more"></a><hr><h3 id="问题环境："><a href="#问题环境：" class="headerlink" title="问题环境："></a>问题环境：</h3><div class="note info"><ul><li>使用nginx+gunicorn+flask搭建webserver的运行环境</li><li>环境进程文件句柄使用数上线未设置过为1024</li><li>gunicorn max-connections=2048 workers=9</li></ul></div><hr><h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><ol><li>ulimit -n 设置过小<ul><li>问题原因比较好定位，google一下大概就确定了</li><li>调大open files应该就可以了</li></ul></li><li>gunicorn max-connections指单个workers还是gunicorn整体的最大连接数？<ul><li>找了官方文档和google的博客均没细说，如果是前者那是有文件句柄不够用的可能性，而后者则可能性不大，最后还是自己看了源码并通过siege进行性能测试得出结论，<code>gunicorn max-connections指单个workers</code>。</li></ul></li></ol><hr><h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ul><li>根据性能测试调大open files，并对数据数值添加监控。</li></ul><hr><h3 id="问题总结："><a href="#问题总结：" class="headerlink" title="问题总结："></a>问题总结：</h3><ul><li><p><strong>linux open files</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 查看系统最大可打开文件数</span><br><span class="line">cat /proc/sys/fs/file-max</span><br><span class="line">2. 查看进程最大可打开文件数</span><br><span class="line">cat /etc/security/limits.conf</span><br><span class="line">3. 查看指定进程文件打开数</span><br><span class="line">lsof -p pid | wc -l </span><br><span class="line">4. 查看gunicorn fork出所有进程的文件打开数</span><br><span class="line">lsof -n|awk &apos;&#123;print $1&#125;&apos;|sort|uniq -c|sort -nr|grep gunicorn</span><br><span class="line">5. 进程 fork() 出来的子进程，会继承父进程的 limits 设定</span><br></pre></td></tr></table></figure></li><li><p><strong>gunicorn</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. work_connections指gunicorn单进程并发数</span><br><span class="line">2. 若gunicorn worker_connections &lt; 当前并发数，请求至多会超时，而不会报连接文件句柄异常</span><br><span class="line">3、当worker_connections &gt; 1 时 且程序可异步操作越久（sleep），gevent作用越明显</span><br></pre></td></tr></table></figure></li><li><p><strong>异常再次发生处理步骤</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. ps -ef |grep gunicorn -&gt; pid</span><br><span class="line">2. cat /proc/pid/limits.conf</span><br><span class="line">3. lsof -p pid |wc -l</span><br><span class="line">4. sudo vi  /etc/security/limits.conf</span><br><span class="line">asset soft nofile 10240</span><br><span class="line">asset hard nofile 10240</span><br><span class="line">5. restart program &amp;&amp; cat /proc/pid/limits.conf</span><br></pre></td></tr></table></figure></li><li><p><strong>性能测试</strong></p><ol><li>性能测试主要使用了siege和locust，siege通过创建线程进行并发对测试机的影响较大，而locust通过协程并发请求，测试并发数能更高，该部分的具体内容会另起篇幅进行总结梳理。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题现象：&quot;&gt;&lt;a href=&quot;#问题现象：&quot; class=&quot;headerlink&quot; title=&quot;问题现象：&quot;&gt;&lt;/a&gt;问题现象：&lt;/h3&gt;&lt;div class=&quot;note warning&quot;&gt;&lt;ul&gt;
&lt;li&gt;webserver服务不可用&lt;/li&gt;
&lt;li&gt;查询日志得知异常为”… Too Many Open Files”&lt;/li&gt;
&lt;li&gt;重启webserver后服务正常可用&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="问题分析" scheme="https://ziperlee.github.io/zipee.github.io/categories/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
    
      <category term="flask" scheme="https://ziperlee.github.io/zipee.github.io/tags/flask/"/>
    
      <category term="问题分析" scheme="https://ziperlee.github.io/zipee.github.io/tags/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="linux" scheme="https://ziperlee.github.io/zipee.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>sqlalchemy数据库连接数异常</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2019/01/22/sqlalchemy%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%95%B0%E5%BC%82%E5%B8%B8/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2019/01/22/sqlalchemy数据库连接数异常/</id>
    <published>2019-01-22T13:03:19.000Z</published>
    <updated>2019-03-10T12:09:01.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题现象："><a href="#问题现象：" class="headerlink" title="问题现象："></a>问题现象：</h3><div class="note warning"><ul><li>web端调用flask接口阻塞，最终超时返回系统异常</li><li>查询日志得知具体异常为超出数据库最大连接数</li><li>重新flask webserver后数据库连接数正常释放</li><li>持续使用系统一段时间后数据库连接数再次封顶</li><li>环境操作用户寥寥无几</li></ul></div><a id="more"></a><hr><h3 id="问题环境："><a href="#问题环境：" class="headerlink" title="问题环境："></a>问题环境：</h3><div class="note info"><ul><li>使用flask搭建webserver的运行环境</li><li>使用flask-sqlalchemy连接数据库并进行相关业务操作，SQLALCHEMY_POOL_SIZE = 64， SQLALCHEMY_POOL_RECYCLE = 30</li><li>mysql设置最大连接数200</li><li>宿主机CPU 2核心</li><li>通过进程数2*2+1 = 5</li></ul></div><hr><h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><ol><li><p>怀疑对flask-sqlalchemy使用不当导致</p><ul><li>问题原因明显是数据库连接使用后没有释放</li><li>数据库操作业务层均使用封装的方法，不存在操作对数据库的连接和释放</li><li>flask-sqlalchemy的连接释放由<code>teardown_appcontext</code>钩子统一处理<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.teardown_appcontext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shutdown_session</span><span class="params">(response_or_exc)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> app.config[<span class="string">'SQLALCHEMY_COMMIT_ON_TEARDOWN'</span>]:</span><br><span class="line">        <span class="keyword">if</span> response_or_exc <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.session.commit()</span><br><span class="line"></span><br><span class="line">    self.session.remove()</span><br><span class="line">    <span class="keyword">return</span> response_or_exc</span><br></pre></td></tr></table></figure></li></ul></li><li><p>mysql数据库连接超出首因</p><ul><li>(2*2+1) * 64 &gt; 200 </li><li>困惑连接数回收已经指定<code>SQLALCHEMY_POOL_RECYCLE=30</code>但未生效</li><li>对<code>SQLALCHEMY_POOL_RECYCLE</code>理解错误，该项真实含义为queue_pool可用连接的回收时间</li><li>当前问题为连接未释放，顾与<code>SQLALCHEMY_POOL_RECYCLE</code>无关</li></ul></li><li>若(2*2+1) * 64 &lt; 200 会不会好点？<ul><li>异常改为<code>QueuePool limit of size &lt;x&gt; overflow &lt;y&gt; reached, connection timed out, timeout &lt;z&gt;</code></li><li>达到queue_pool的最大限制后同样是无法连接数据库，只是换了种“死法”</li></ul></li></ol><p><strong>分析到这里仍旧没有头绪…</strong></p><hr><h3 id="问题排查："><a href="#问题排查：" class="headerlink" title="问题排查："></a>问题排查：</h3><ul><li><p><strong>查询数据库连接数</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA. PROCESSLIST</span><br></pre></td></tr></table></figure></li><li><p><strong>linux下查询连接端口对应的进程</strong></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:48057|grep celery|awk   '&#123;print$2&#125;'|xargs -I&#123;&#125; echo 'ps -ef|grep &#123;&#125;'|bash</span><br></pre></td></tr></table></figure></li><li><p><strong>windows下查询连接端口对应的进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano|findstr "8080"</span><br><span class="line">tasklist|findstr [进程号]</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ul><li>问题调试发现单接口调用连接数并未按预期增长</li><li>通过页面使用操作连接数会不规则的增长</li><li>逐个接口比对，最终发现在调用sse长连接接口后，连接数会稳定增长1</li><li>分析sse仅操作了redis，并未存在对mysql的相关操作</li><li>调试发现调用sse会进入@after_request请求钩子中，而在该钩子处理函数中使用了current_user，即调用了数据库</li><li>到此真相大白，代码修改很简单过滤该url既可，但问题的思考排查真实饶了一大圈</li></ul><hr><h3 id="问题总结："><a href="#问题总结：" class="headerlink" title="问题总结："></a>问题总结：</h3><ul><li>最后反思，其实在确定flask-sqlalchemy框架层在正常api逻辑处理中会自动释放连接后，就应该直接猜测是非业务短连接接口导致，但这其中的盲点主要在sse正常情况下是与mysql毫不相干的，顾很容易忽略sse的长连接问题</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题现象：&quot;&gt;&lt;a href=&quot;#问题现象：&quot; class=&quot;headerlink&quot; title=&quot;问题现象：&quot;&gt;&lt;/a&gt;问题现象：&lt;/h3&gt;&lt;div class=&quot;note warning&quot;&gt;&lt;ul&gt;
&lt;li&gt;web端调用flask接口阻塞，最终超时返回系统异常&lt;/li&gt;
&lt;li&gt;查询日志得知具体异常为超出数据库最大连接数&lt;/li&gt;
&lt;li&gt;重新flask webserver后数据库连接数正常释放&lt;/li&gt;
&lt;li&gt;持续使用系统一段时间后数据库连接数再次封顶&lt;/li&gt;
&lt;li&gt;环境操作用户寥寥无几&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="问题分析" scheme="https://ziperlee.github.io/zipee.github.io/categories/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
    
      <category term="问题分析" scheme="https://ziperlee.github.io/zipee.github.io/tags/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
      <category term="mysql" scheme="https://ziperlee.github.io/zipee.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>python代码pyc化加密部署</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2018/12/30/python%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86%E9%83%A8%E7%BD%B2/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2018/12/30/python代码加密部署/</id>
    <published>2018-12-30T08:45:56.000Z</published>
    <updated>2018-12-30T09:58:22.173Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>python不像c，java等编译型语言（编译后发布机器码），解释型则必须把源码发布出去，但仍存在一些交付场景希望能够将python代码加密。</p></div><a id="more"></a><h3 id="为什么转换为pyc？"><a href="#为什么转换为pyc？" class="headerlink" title="为什么转换为pyc？"></a>为什么转换为pyc？</h3><ul><li>pyc官方的解释还请自行google</li><li>简而言之，pyc文件为字节码文件，单个.py生成.pyc文件后运行效果相同</li><li>pyc文件运行效率高于py文件（少了解释器对源码的转换）</li><li>pyc虽然可以进行逆向转换，但不一定可靠（没试过），不过已经满足了简单加密的需求，毕竟源码裸奔交付是心理上不能接收的</li></ul><h3 id="如何转换为pyc？"><a href="#如何转换为pyc？" class="headerlink" title="如何转换为pyc？"></a>如何转换为pyc？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m compileall (file or dir) -b</span><br></pre></td></tr></table></figure><ul><li>-b 支持生成pyc文件于当前目录而非<code>__pycache__</code></li></ul><h3 id="配合jenkins进行自动集成发布"><a href="#配合jenkins进行自动集成发布" class="headerlink" title="配合jenkins进行自动集成发布"></a>配合jenkins进行自动集成发布</h3><ul><li>基于flask开发目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/app</span><br><span class="line">/conf</span><br><span class="line">/tests</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> /bin/sh</span><br><span class="line"></span><br><span class="line">function timeoutController()&#123;</span><br><span class="line">    cmd=$1</span><br><span class="line">    timeout=$2</span><br><span class="line">    mod=$3</span><br><span class="line">    count=1</span><br><span class="line">    while [ $count -le 3 ]; do</span><br><span class="line">        timeout $timeout $cmd</span><br><span class="line">        exitCode=$?</span><br><span class="line">        if [[ $exitCode == 0 ]] || [[ $exitCode -ne 124 ]]; then</span><br><span class="line">            break</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        if [ $exitCode == 124 ]; then</span><br><span class="line">            echo "module: &#123;$mod&#125; timeout &#123;$timeout&#125; s and start to &#123;$count&#125; time retry"</span><br><span class="line">        fi</span><br><span class="line">        count=`expr $count + 1`</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    if [ $exitCode -ne 0 ]; then</span><br><span class="line">        echo $mod "=====================&gt;unittest failed"</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function code_encrypt()&#123;</span><br><span class="line">    release_dir=$1</span><br><span class="line">    pyc_dir=$2</span><br><span class="line"></span><br><span class="line">    # release svn del .svn</span><br><span class="line">    find $release_dir -name ".svn" | xargs rm -rf</span><br><span class="line"></span><br><span class="line">    # svn del pyc</span><br><span class="line">    cd $pyc_dir</span><br><span class="line">    svn rm * --force</span><br><span class="line">    svn ci -m "pyc delete"</span><br><span class="line"></span><br><span class="line">    # cp release code to pyc &amp;&amp; encrypt code</span><br><span class="line">    cp $release_dir/* $pyc_dir -R</span><br><span class="line">    python -m compileall . -b</span><br><span class="line">    find . -name "*.py" | xargs rm</span><br><span class="line">    rm tests/report -rf</span><br><span class="line">    # replace gunicorn.pyc with gunicorn.py</span><br><span class="line">    rm $pyc_dir/conf/gunicorn.pyc</span><br><span class="line">    cp $release_dir/conf/gunicorn.py $pyc_dir/conf/</span><br><span class="line"></span><br><span class="line">    # pyc svn commit</span><br><span class="line">    svn add . --no-ignore --force</span><br><span class="line">    svn ci -m "pyc commit"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()&#123;</span><br><span class="line">    echo "========================== init env ============="</span><br><span class="line">    source /root/anaconda3/bin/activate py3</span><br><span class="line">    release_dir="/home/pro/pro_release"</span><br><span class="line">    pyc_dir="/home/pro/pro_pyc"</span><br><span class="line">    release_svn_dir="http://*.*.*.*/"</span><br><span class="line"></span><br><span class="line">    # update tag:release code</span><br><span class="line">    rm $release_dir -rf</span><br><span class="line">    svn co $release_svn_dir</span><br><span class="line"></span><br><span class="line">    echo "========================== flake8 ==============="</span><br><span class="line">    cd $release_dir</span><br><span class="line">    timeoutController "flake8 --config=$&#123;release_dir&#125;/.config/flake8 $&#123;release_dir&#125;" 60 "flake8"</span><br><span class="line"></span><br><span class="line">    echo "========================== pytest ==============="</span><br><span class="line">    cd $release_dir/tests</span><br><span class="line">    timeoutController "pytest ."</span><br><span class="line"></span><br><span class="line">    echo "========================== code encrypt ============="</span><br><span class="line">    code_encrypt $release_dir $pyc_dir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main</span><br></pre></td></tr></table></figure><div class="note warning"><ul><li>以上脚本基于svn代码管理，如使用git，则flake8，pytest测试可通过git hook，而单单保留代码加密</li><li>gunicorn 貌似不支持指定pyc为配置文件，但这不影响整体的加密效果，后续可以在研究研究，毕竟对于我这种重度洁癖患者，留这一个.py文件就像一个小疙瘩，总想给它挠掉</li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;python不像c，java等编译型语言（编译后发布机器码），解释型则必须把源码发布出去，但仍存在一些交付场景希望能够将python代码加密。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="python" scheme="https://ziperlee.github.io/zipee.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://ziperlee.github.io/zipee.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>flask服务端推送</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2018/11/25/flask%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2018/11/25/flask服务端推送/</id>
    <published>2018-11-25T07:09:26.000Z</published>
    <updated>2018-11-25T08:32:04.262Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文用以记录在<code>flask-sse</code>使用中踩到的坑及解决方案。</p></div><a id="more"></a><h3 id="当前主流的服务端推送方案"><a href="#当前主流的服务端推送方案" class="headerlink" title="当前主流的服务端推送方案"></a>当前主流的服务端推送方案</h3><ol><li>客户端短连接轮询</li><li>websocket</li><li>Server Send Event（SSE）</li></ol><p>相较于轮询的方式，websocket和sse会稍显高级而不是无脑的轮询浪费网络资源。<br>在最近一次的方案选型中，我选择了sse，理由是websocket是双工，且需要单独的服务，而项目的需求仅是向客户端进行简单的推送信息，对比之下sse更显轻量且开发量更少。</p><hr><h3 id="使用过程中遇到的困难"><a href="#使用过程中遇到的困难" class="headerlink" title="使用过程中遇到的困难"></a>使用过程中遇到的困难</h3><ul><li><p><strong><code>flask-sse</code> redis连接释放问题</strong><br>该库目前存在缺陷，当浏览器刷新或者网关断开重连时会重新<code>new EventSource</code>，然而服务端并无法得知连接的断开，导致redis连接数会一直增加。<br>唯一释放的机会在于当再次收到推送信息，协程被唤醒并产生<code>GeneratorExit</code>异常<br>因此代码中未对异常捕获，将错过最后一次释放reids连接的机会：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@stream_with_context</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> message <span class="keyword">in</span> self.messages(channel=channel):</span><br><span class="line">        <span class="keyword">yield</span> str(message)</span><br><span class="line">        self.redis.connection_pool.disconnect()</span><br></pre></td></tr></table></figure><p>  修改的代码已上传github，并提交merge，但是由于没有通过python2的测试用例导致未被合并（懒得适配），有兴趣的童鞋可以直接查看我fork提交的代码。</p><p>  <code>redis连接数查看</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a pwd -h *.*.*.* info | grep client</span><br></pre></td></tr></table></figure></li><li><p><strong>程序阻塞问题</strong><br>由于最开始使用之前未仔细看官方的实用说明和源码，发现uwsgi实用进程线程的启动模式，程序运行几次之后就阻塞了，最后发现正确的打开方式是使用协程的方式驱动http服务。</p><p>  另外还有一点现象，当使用flask自带的http服务器进行多线程<code>threaded=True</code>调试时redis连接能一次性释放掉，而当使用gunicorn+gevent方式运行时却没有一步到位的效果，原因是协程是异步的，一次<code>最多</code>能唤醒对应进程数量的协程，所以redis的释放问题最终还是需要通过定时推送心跳包的方式解决，推荐使用<code>celery</code>。</p></li><li><p><strong>网关超时问题</strong><br>网关基本都会有超时设置，而浏览器的断线重连貌似对于504的异常并不起作用。<br>  因此需要针对超时异常进行特殊处理。<br>  这里给出<a href="https://github.com/BotBotMe/botbot-web/issues/2" target="_blank" rel="noopener">nginx配置</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /eventsource &#123;</span><br><span class="line">include uwsgi_params;</span><br><span class="line">uwsgi_pass eventsource-botbot-backend;</span><br><span class="line">uwsgi_buffering off;</span><br><span class="line">chunked_transfer_encoding off;</span><br><span class="line">proxy_cache off;</span><br><span class="line">access_log  /var/log/nginx/eventsource_botbot.access.log;</span><br><span class="line">error_page 504 =200 @eventsource-close-graceful;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location @eventsource-close-graceful &#123;</span><br><span class="line">add_header Content-Type text/event-stream;</span><br><span class="line">return 200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>注意</code>每个nginx网关就需要配置</p></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/singingwolfboy/flask-sse" target="_blank" rel="noopener">官方用例</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文用以记录在&lt;code&gt;flask-sse&lt;/code&gt;使用中踩到的坑及解决方案。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="flask" scheme="https://ziperlee.github.io/zipee.github.io/categories/flask/"/>
    
    
      <category term="flask" scheme="https://ziperlee.github.io/zipee.github.io/tags/flask/"/>
    
      <category term="sse" scheme="https://ziperlee.github.io/zipee.github.io/tags/sse/"/>
    
  </entry>
  
  <entry>
    <title>win10docker使用填坑</title>
    <link href="https://ziperlee.github.io/zipee.github.io/2018/11/04/win10docker%E4%BD%BF%E7%94%A8%E5%A1%AB%E5%9D%91/"/>
    <id>https://ziperlee.github.io/zipee.github.io/2018/11/04/win10docker使用填坑/</id>
    <published>2018-11-04T05:17:09.000Z</published>
    <updated>2018-11-04T13:45:50.108Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>本文用以记录在<code>docker win10</code>环境使用中踩到的坑及解决方案。</p></div><a id="more"></a><h2 id="问题一：docker修改配置或者镜像的存储位置后启动异常"><a href="#问题一：docker修改配置或者镜像的存储位置后启动异常" class="headerlink" title="问题一：docker修改配置或者镜像的存储位置后启动异常"></a>问题一：docker修改配置或者镜像的存储位置后启动异常</h2><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><em>解决方案</em>：</h3><div class="note warning"><ul><li>移动|剪切 C:\Users\Public\Documents\Hyper-V\Virtual hard disks\MobyLinuxVM.vhdx 再重启电脑</li></ul></div><hr><h2 id="问题二：修改镜像存储位置"><a href="#问题二：修改镜像存储位置" class="headerlink" title="问题二：修改镜像存储位置"></a>问题二：修改镜像存储位置</h2><h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a><em>解决方案</em>：</h3><div class="note warning"><ul><li>默认位置：C:\Users\Public\Documents\Hyper-V\Virtual hard disks\MobyLinuxVM.vhdx</li><li>修改：Hyper-V管理器<strong>Hyper-v设置</strong>虚拟硬盘修改路径</li></ul></div><hr><h2 id="问题三：docker安装mysql8-0容器后，是用navicat连接报client-does-not-support-authentication-protocol-requested-by-server-consider-upgrading-mysql-client"><a href="#问题三：docker安装mysql8-0容器后，是用navicat连接报client-does-not-support-authentication-protocol-requested-by-server-consider-upgrading-mysql-client" class="headerlink" title="问题三：docker安装mysql8.0容器后，是用navicat连接报client does not support authentication protocol requested by server consider upgrading mysql client"></a>问题三：docker安装mysql8.0容器后，是用navicat连接报client does not support authentication protocol requested by server consider upgrading mysql client</h2><h3 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a><em>解决方案</em>：</h3><div class="note warning"><ul><li>进入容器<br>docker exec -it mysql bash</li><li>进入mysql<br>mysql -u root -p</li><li>创建root用户<br>CREATE USER ‘root‘@’%’ IDENTIFIED IDENTIFIED WITH <code>mysql_native_password</code> BY ‘123456’;</li><li>设置root用户访问权限<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root‘@’%’ WITH GRANT OPTION;</li><li>重置密码<br>ALTER USER ‘root‘@’%’ IDENTIFIED WITH <code>mysql_native_password</code> BY ‘123456’;<br>ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH <code>mysql_native_password</code> BY ‘123456’;</li><li>提交修改<br>FLUSH PRIVILEGES;</li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;本文用以记录在&lt;code&gt;docker win10&lt;/code&gt;环境使用中踩到的坑及解决方案。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="docker" scheme="https://ziperlee.github.io/zipee.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://ziperlee.github.io/zipee.github.io/tags/docker/"/>
    
      <category term="wins10" scheme="https://ziperlee.github.io/zipee.github.io/tags/wins10/"/>
    
  </entry>
  
</feed>
