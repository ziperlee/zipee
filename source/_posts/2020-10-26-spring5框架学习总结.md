---
title: spring5框架学习总结
date: 2020-10-26 17:09:06
tags: spring
categories: java
---

{%note info%}

java后段必备技术栈

{%endnote%}
<!--more-->



### Spring 框架概述

- 轻量级开源 JavaEE 框架，为了解决企业复杂性，两个核心组成： IOC 和 AOP
- 整体架构如下



![20201022145213.jpg](https://i.loli.net/2020/10/22/JKBwDbgmORQLvFp.jpg)

---

### IOC 容器

#### what

1. 控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理
2. 使用 IOC 目的：为了耦合度降低

#### ioc原理
xml 解析、工厂模式、反射

#### ioc接口

1. BeanFactory： IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用
    - 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象
2. ApplicationContext： `BeanFactory 接口的子接口`，提供更多更强大的功能，一般由开发人员进行使用
    - 加载配置文件时候就会把在配置文件对象进行创建

#### Bean 管理

- 基于 xml

  - 创建对象
          ``` 
          <bean id="user" class="com.zipee.spring5.User"></bean>
          ```
  - 注入属性
      - DI：依赖注入，就是注入属性
          - 手动注入（xml中指定）
          - `自动注入`（自动装配）

- 基于注解

  - 创建对象

      - 注解类型（以下四个注解功能是一样的，都可以用来创建 bean 实例）      
        - @Component
           - @Service
        - @Controller
           - @Repository

      1. 引入依赖（spring-aop jar包）

      2. 开启组件扫描

            - 如果扫描多个包，多个包使用逗号隔开

         - 扫描包上层目录

               ``` java
              <context:component-scan base-package="com.zipee"></context:component-scan>
               ```

      3. 创建类，在类上面添加创建对象注解
      4. 开启组件扫描细节配置（可以指定扫描过滤器）

  - 注入属性

       - @Autowired
            - 根据属性类型进行自动装配
       - @Qualifier
            - 根据名称进行注入（需要和@Autowired 一起使用）
       - @Resource（javax中定义，建议使用Autowired和Qualifier）
            - 可以根据类型注入，可以根据名称注入
       - @Value
            - 注入普通类型属性

   - 完全注解开发（springboot）

     1. 完全注解开发
                 ``` java
             @Configuration //作为配置类，替代 xml 配置文件
             @ComponentScan(basePackages = {"com.zipee"})
             public class SpringConfig {
             }
                 ```

     2. 通过配置类获取ioc容器
                 ``` java
             ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
                 ```

### bean分类
- 普通bean
    
    - 在配置文件中定义 bean 类型就是返回类型
- 工厂bean（FactoryBean）
    - 在配置文件定义 bean ==类型可以和返回类型不一样==
    1. 创建类，让这个类作为工厂 bean，实现接口 FactoryBean
    2. 实现接口里面的方法，在实现的方法中定义返回的 bean 类型
    
### bean作用域
1. 在 Spring 里面，设置创建 bean 实例是单实例还是多实例
2. 在 Spring 里面，默认情况下， bean 是单实例对象
3. scope 属性值
    - singleton
        - 加载 spring 配置文件时候就会创建单实例对象
    - prototype
        - 在调用getBean 方法时候创建多实例对象

### bean 生命周期
1. 通过构造器创建 bean 实例（无参数构造）
2. 为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）
3. 把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization
4. 调用 bean 的初始化的方法（需要进行配置初始化的方法）
5. 把 bean 实例传递 bean 后置处理器的方法 ostProcessAfterInitialization
6. bean 可以使用了（对象获取到了）
7. 当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）

- 使用后置处理器
    1. 创建类，实现接口 BeanPostProcessor，创建后置处理器 
    2. 后置处理器对所有的bean都会生效

---

### Aop

#### 实现原理

1. 有接口情况，使用 JDK 动态代理
    - 创建接口实现类代理对象，增强类的方法
    - 实际使用Proxy动态创建代理对象
2. 没有接口情况，使用 CGLIB 动态代理
    - 创建子类的代理对象，增强类的方法

#### 术语

1. 连接点
    
    - 类里面可以被增强的方法
2. 切入点
    - 实际被真正增强的方法
    - 使用
        - 语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) )（返回类型一般可省略为空格）
        - 对 com.atguigu.dao.BookDao 类里面的 add 进行增强
            ``` 
            execution(* com.zipee.dao.BookDao.add(..))
            ```
        - 对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强
            ``` 
            execution(* com.zipee.dao.BookDao.*(..))
            ```
        - 对 com.atguigu.dao包里面所有类，类里面所有方法进行增强
            ``` 
            execution(* com.zipee.dao.*.*(..))
            ```
    
3. 通知（增强）
    - 实际增强的逻辑
    - 通知种类
        - 前置通知
        - 后置通知
        - 环绕通知
        - 异常通知
        - 最终通知
4. 切面
    
    - 把通知应用到切入点的过程

#### AspectJ

- AspectJ为独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作
- 使用
    - 基于 xml 配置文件实现
    - 基于注解方式实现

#### aop使用步骤

1. 创建类，在类里面定义方法
2. 创建增强类（编写增强逻辑）
    - 在增强类上面添加注解 @Aspect
    - 在增强类的里面，在作为通知方法上面添加通知类型注解（@Before，@After...），使用切入点表达式配置
3. 进行通知的配置
    - 开启注解扫描 @ComponentScan(basePackages = {"com.zipee"})
    - 在 spring 配置文件中开启生成代理对象 @EnableAspectJAutoProxy(proxyTargetClass = true)
4. 相同的切入点抽取 @Pointcut
5. 有多个增强类多同一个方法进行增强，设置增强类优先级 @Order，数字类型值越小优先级越高

---

### 事务管理

#### 注解声明式事务管理
1. 在 spring 配置文件配置事务管理器
    ``` java
    <!--创建事务管理器-->
    <bean id="transactionManager"
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <!--注入数据源-->
    <property name="dataSource" ref="dataSource"></property>
    </bean>
    ```
2. 在 spring 配置文件，开启事务注解
    - 在 spring 配置文件引入名称空间 tx
    - 开启事务注解
    - 在 service 类上面（ 或者 service 类里面方法上面）添加事务注解(@Transactional)
3. 参数配置说明
    - propagation：事务传播行为
        - REQUIRED 若已有事物则复用，无则新建
        - REQUIRED_NEW 若已有事物则挂起，无则新建
        - SUPPORTS
        - NOT_SUPPORTED
        - MANDATORY
    - ioslation：事务隔离级别
        - 有三个读问题
            - 脏读
                - 一个未提交事务读取到另一个未提交事务的数据
            - 不可重复读
                - 一个未提交事务读取到另一提交事务修改数据
            - 虚（幻）读
                - 一个未提交事务读取到另一提交事务添加数据
    - timeout：超时时间
        - 事务需要在一定时间内进行提交，如果不提交进行回滚
        - 默认值是 -1 ，设置时间以秒单位进行计算
    - readOnly：是否只读
        - 读：查询操作，写：添加修改删除操作
        - readOnly 默认值 false，表示可以查询，可以添加修改删除操作
        - 设置 readOnly 值是 true，设置成 true 之后，只能查询
    - rollbackFor：回滚
        - 设置出现哪些异常进行事务回滚
    - noRollbackFor：不回滚
        - 设置出现哪些异常不进行事务回滚
        
|                               | 脏读 | 不可重复度 | 幻读 |
| :---------------------------- | :--: | :--------: | :--: |
| READ UNCOMMITTED （读未提交） |  Y   |     Y      |  Y   |
| READ COMMITTED （读已提交）   |  N   |     Y      |  Y   |
| REPEATABLE READ （可重复度）  |  N   |     N      |  Y   |
| SERIALIZABLE （串行化）       |  N   |     N      |  N   |



#### XML 声明式事务管理
- 在 spring 配置文件中进行配置
    - 配置事务管理器
    - 配置通知
    - 配置切入点和切面

#### 完全注解声明式事务管理
1. 创建配置类，使用配置类替代 xml 配置文件 @Configuration
2. 开启组建扫描 @ComponentScan
3. 开启事物 @EnableTransactionManagement
4. 创建数据库连接池
5. 创建 JdbcTemplate 对象
6. 创建事务管理器
``` java
@Configuration //配置类
@ComponentScan(basePackages = "com.zipee") //组件扫描
@EnableTransactionManagement //开启事务
public class TxConfig {
    //创建数据库连接池
    @Bean
    public DruidDataSource getDruidDataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql:///user_db");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        return dataSource;
    }
    //创建 JdbcTemplate 对象
    @Bean
    public JdbcTemplate getJdbcTemplate(DataSource dataSource) {
        //到 ioc 容器中根据类型找到 dataSource
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        //注入 dataSource
        jdbcTemplate.setDataSource(dataSource);
        return jdbcTemplate;
    }
    //创建事务管理器
    @Bean
    public DataSourceTransactionManager
        getDataSourceTransactionManager(DataSource dataSource) {
        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();
        transactionManager.setDataSource(dataSource);
        return transactionManager;
    }
}
```

---

### Spring5 新功能
- 支持@Nullable 注解
     - @Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空

- 支持函数式风格
- 整合 JUnit5 单元测试框架
- 新增SpringWebflux 